{"version":3,"sources":["devices/camera/VideoElement.tsx","devices/camera/BigScreen.tsx","devices/camera/CameraPicker.tsx","devices/camera/Hide.tsx","devices/camera/Json.tsx","devices/camera/RecordingDirector.ts","devices/camera/MediaStreamTrackView.tsx","devices/camera/VideoView.tsx","devices/camera/CameraDemonstrator.tsx","serviceWorker.ts","index.tsx"],"names":["VideoElement","srcObject","muted","rest","videoElement","useRef","useEffect","node","current","ref","BigScreen","props","handleVideoClicked","recordingDirector","clearCameraSelection","handleDeviceSelectionChange","device","closeExistingStream","setState","undefined","mediaStreamSubscription","videoStreamSubscriptionFor","stream","then","catch","streamError","state","this","addOnCameraSelectionChanged","removeOnCameraSelectionChanged","autoPlay","onClick","id","maybeSubscription","cancel","React","Component","CameraPreview","handleSelect","selectCamera","maybeStream","index","label","deviceId","groupId","width","CameraPicker","handleShowPreview","showPreviews","handleHidePreview","button","previews","cameras","map","key","style","display","flexDirection","Hide","hide","Fragment","children","Json","content","contentAsJsonString","JSON","stringify","doNothing","MediaStreamSubscription","subscriptionDetails","canceled","cancelSubscription","Promise","reject","SubscriptionLedger","subscriptionsByDevice","Map","entry","get","subscribers","Set","set","add","subscriberIdentifier","onNoMoreSubscribers","delete","size","RecordingDirector","subscriptionLedger","devices","onCameraSelectionChangedListeners","selectedCamera","newDevices","splice","length","push","filter","kind","streamForDevice","uuid","addSubscriber","removeSubscriber","close","maybeAlreadyAvailableStream","streamFor","videoStreamFor","navigator","mediaDevices","getUserMedia","video","camera","console","log","forEach","listener","getTracks","track","stop","MediaStreamTrackView","readyState","String","enabled","getCapabilities","getConstraints","getSettings","VideoView","handleStart","source","err","alert","handlePause","tracks","triggerRender","handleContinue","handleStop","handleDetach","title","logDeviceInformation","enumerateDevices","devicesString","join","e","CameraDemonstrator","getSupportedConstraints","Boolean","window","location","hostname","match","Demonstrator","updateDevices","mediaDeviceInfos","mediaDeviceInfo","name","message","fetchDevices","addEventListener","setupCameraDemonstrator","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.feaf506c.chunk.js","sourcesContent":["import React, { useEffect, useRef } from 'react';\n\nexport interface HTMLVideoElementProps extends React.VideoHTMLAttributes<HTMLVideoElement> {\n    srcObject: MediaStream | null;\n}\n\nexport const VideoElement: React.FC<HTMLVideoElementProps> = ({ srcObject = null, muted = false, ...rest }) => {\n    const videoElement = useRef<HTMLVideoElement>(null);\n    useEffect(() => {\n        const node = videoElement.current;\n        if (node === null) {\n            return;\n        }\n        if (node.srcObject !== srcObject) {\n            node.srcObject = srcObject;\n        }\n        if (node.muted !== muted) {\n            node.muted = muted;\n        }\n    }, [srcObject, muted]);\n    return <video {...rest} ref={videoElement}/>;\n};\n","import React from 'react';\nimport { Device, MediaStreamSubscription, RecordingDirector } from './RecordingDirector';\nimport { VideoElement } from './VideoElement';\n\nexport interface BigScreenProps {\n    recordingDirector: RecordingDirector;\n}\n\nexport interface BigScreenState {\n    device: Device | void;\n    stream: MediaStream | null;\n    mediaStreamSubscription: MediaStreamSubscription | undefined;\n    streamError: boolean;\n}\n\nexport class BigScreen extends React.Component<BigScreenProps, BigScreenState> {\n\n    constructor(props: BigScreenProps) {\n        super(props);\n        this.state = { streamError: false, stream: null, mediaStreamSubscription: undefined, device: undefined };\n    }\n\n    componentDidMount(): void {\n        this.props.recordingDirector.addOnCameraSelectionChanged(this.handleDeviceSelectionChange);\n    }\n\n    componentWillUnmount(): void {\n        this.props.recordingDirector.removeOnCameraSelectionChanged(this.handleDeviceSelectionChange);\n        this.closeExistingStream();\n        this.setState({ device: undefined, streamError: false });\n    }\n\n    render() {\n        if (this.state.device === undefined) {\n            return <div>No device selected</div>;\n        }\n        if (this.state.stream === null) {\n            return <div>Opening stream</div>;\n        }\n        return (\n            <div>\n                {<VideoElement srcObject={this.state.stream} autoPlay={true} onClick={this.handleVideoClicked}/>}\n                <div>{this.state.stream.id}</div>\n            </div>\n\n        );\n    }\n\n    private handleVideoClicked = () => {\n        this.props.recordingDirector.clearCameraSelection();\n    }\n\n    private handleDeviceSelectionChange = (device: Device | void): void => {\n        this.closeExistingStream();\n        this.setState({ device }, () => {\n            if (device === undefined) {\n                return;\n            }\n            const mediaStreamSubscription = this.props.recordingDirector.videoStreamSubscriptionFor(device);\n            this.setState({ mediaStreamSubscription });\n            mediaStreamSubscription.stream\n                .then(stream => this.setState({ stream }))\n                .catch(() => this.setState({ streamError: true }));\n        });\n    };\n\n    private closeExistingStream() {\n        const maybeSubscription = this.state.mediaStreamSubscription;\n        if (maybeSubscription !== undefined) {\n            maybeSubscription.cancel();\n            this.setState({ stream: null, mediaStreamSubscription: undefined });\n        }\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { VideoElement } from './VideoElement';\nimport { Device, MediaStreamSubscription, RecordingDirector } from './RecordingDirector';\n\nexport interface CameraPreviewProps {\n    recordingDirector: RecordingDirector;\n    device: Device;\n    index: number;\n}\n\nexport interface CameraPreviewState {\n    mediaStreamSubscription: MediaStreamSubscription | undefined\n    stream: MediaStream | null;\n    streamError: boolean;\n}\n\nexport class CameraPreview extends React.Component<CameraPreviewProps, CameraPreviewState> {\n\n    constructor(props: CameraPreviewProps) {\n        super(props);\n        this.state = { mediaStreamSubscription: undefined, streamError: false, stream: null };\n    }\n\n    componentDidMount(): void {\n        const mediaStreamSubscription = this.props.recordingDirector.videoStreamSubscriptionFor(this.props.device);\n        this.setState({ mediaStreamSubscription });\n        mediaStreamSubscription.stream\n            .then(stream => this.setState({ stream }))\n            .catch(() => this.setState({ streamError: true }));\n    }\n\n    componentWillUnmount(): void {\n        const maybeSubscription = this.state.mediaStreamSubscription;\n        if (maybeSubscription !== undefined) {\n            maybeSubscription.cancel();\n            this.setState({ stream: null, mediaStreamSubscription: undefined });\n        }\n    }\n\n    render() {\n        const maybeStream = this.state.stream;\n        const device = this.props.device;\n        return (\n            <div>\n                <h4>Camera {this.props.index}</h4>\n                <ul>\n                    <li>device label: {device.label}</li>\n                    <li>device id: {device.deviceId}</li>\n                    <li>group id: {device.groupId}</li>\n                    <li>stream id: {maybeStream?.id ?? 'no-stream'}</li>\n                </ul>\n                {<VideoElement onClick={this.handleSelect} width={150} srcObject={maybeStream} autoPlay={true}/>}\n            </div>\n        );\n    }\n\n    private handleSelect = () => {\n        this.props.recordingDirector.selectCamera(this.props.device);\n    };\n}\n\nexport interface CameraPickerProps {\n    recordingDirector: RecordingDirector\n}\n\nexport interface CameraPickerState {\n    showPreviews: boolean;\n}\n\nexport class CameraPicker extends React.Component<CameraPickerProps, CameraPickerState> {\n\n    constructor(props: CameraPickerProps) {\n        super(props);\n        this.state = { showPreviews: false };\n    }\n\n    render() {\n        const button = this.state.showPreviews ? <button onClick={this.handleHidePreview}>Hide Previews</button> : <button onClick={this.handleShowPreview}>Show Previews</button>;\n        const previews = this.state.showPreviews ? this.props.recordingDirector.cameras()\n            .map((device, index) => <CameraPreview key={device.deviceId} index={index} device={device} recordingDirector={this.props.recordingDirector}/>) : null;\n        const style: CSSProperties = {\n            display: 'flex',\n            flexDirection: 'column'\n        };\n        return (\n            <div style={style}>\n                {button}\n                {previews}\n            </div>\n        );\n    }\n\n    private handleShowPreview = () => {\n        this.setState({ showPreviews: true });\n    };\n\n    private handleHidePreview = () => {\n        this.setState({ showPreviews: false });\n    };\n}\n","import React from 'react';\n\nexport interface HideProps {\n    hide: boolean;\n}\n\nexport class Hide extends React.Component<HideProps> {\n    render(){\n        if (this.props.hide) {\n            return null;\n        }\n        return (\n            <React.Fragment>\n                {this.props.children}\n            </React.Fragment>\n        );\n    }\n}\n","import React from 'react';\n\ninterface JsonProps {\n    content: any;\n}\n\nexport const Json: React.FC<JsonProps> = ({ content}) => {\n    const contentAsJsonString = JSON.stringify(content, null, 2);\n    return <pre>{contentAsJsonString}</pre>\n};\n","import { uuid } from 'uuidv4';\n\nexport type Device = Pick<MediaDeviceInfo, 'groupId' | 'deviceId' | 'kind' | 'label'>;\n\nexport type OnCameraSelectionChangedListener = (newCamera: Device | void) => void;\n\ninterface SubscriptionDetails {\n    readonly device: Device;\n    readonly subscriberIdentifier: string;\n    stream: Promise<MediaStream>\n}\n\nconst doNothing = () => {\n};\n\nexport class MediaStreamSubscription {\n    private canceled = false;\n\n    constructor(\n        private readonly recordingDirector: RecordingDirector,\n        private readonly subscriptionDetails: SubscriptionDetails) {\n    }\n\n    get stream() {\n        if (this.canceled) {\n            return Promise.reject('subscription canceled');\n        }\n        return this.subscriptionDetails.stream;\n    }\n\n    cancel() {\n        this.recordingDirector.cancelSubscription(this.subscriptionDetails);\n        this.canceled = true;\n    }\n}\n\n\ninterface SubscriptionLedgerEntry {\n    subscribers: Set<string>;\n    stream: Promise<MediaStream>;\n}\n\nclass SubscriptionLedger {\n    private readonly subscriptionsByDevice: Map<string, SubscriptionLedgerEntry> = new Map();\n\n    addSubscriber(subscriptionDetails: SubscriptionDetails) {\n        const deviceId = subscriptionDetails.device.deviceId;\n        let entry = this.subscriptionsByDevice.get(deviceId);\n        if (entry === undefined) {\n            entry = { stream: subscriptionDetails.stream, subscribers: new Set<string>() };\n            this.subscriptionsByDevice.set(deviceId, entry)\n        }\n        entry.subscribers.add(subscriptionDetails.subscriberIdentifier)\n    }\n\n    removeSubscriber(subscriptionDetails: SubscriptionDetails, onNoMoreSubscribers: (stream: Promise<MediaStream>) => void = doNothing) {\n        const entry = this.subscriptionsByDevice.get(subscriptionDetails.device.deviceId);\n        if (entry === undefined) {\n            return;\n        }\n        entry.subscribers.delete(subscriptionDetails.subscriberIdentifier);\n        if (entry.subscribers.size === 0) {\n            this.subscriptionsByDevice.delete(subscriptionDetails.device.deviceId);\n            onNoMoreSubscribers(entry.stream);\n        }\n    }\n\n    streamFor(device: Device): Promise<MediaStream> | undefined {\n        const entry = this.subscriptionsByDevice.get(device.deviceId);\n        if (entry === undefined) {\n            return undefined;\n        }\n        return entry.stream;\n    }\n}\n\nexport class RecordingDirector {\n    private readonly subscriptionLedger = new SubscriptionLedger();\n    private readonly devices: Array<Device> = [];\n    private onCameraSelectionChangedListeners: Set<OnCameraSelectionChangedListener> = new Set<OnCameraSelectionChangedListener>();\n    private selectedCamera: Device | undefined;\n\n    updateDevices(newDevices: Array<Device>) {\n        this.devices.splice(0, this.devices.length);\n        this.devices.push(...newDevices);\n    }\n\n    cameras() {\n        return this.devices.filter(device => device.kind === 'videoinput').filter(device => 'default' !== device.label);\n    }\n\n    videoStreamSubscriptionFor(device: Device): MediaStreamSubscription {\n        let subscriptionDetails = {\n            device,\n            stream: this.streamForDevice(device),\n            subscriberIdentifier: uuid()\n        };\n        this.subscriptionLedger.addSubscriber(subscriptionDetails);\n        return new MediaStreamSubscription(this, subscriptionDetails);\n    }\n\n    cancelSubscription(subscriptionDetails: SubscriptionDetails): void {\n        this.subscriptionLedger.removeSubscriber(subscriptionDetails, (stream) => stream.then(this.close).catch(doNothing));\n    }\n\n    private streamForDevice(device: Device): Promise<MediaStream> {\n        const maybeAlreadyAvailableStream = this.subscriptionLedger.streamFor(device);\n        if (maybeAlreadyAvailableStream !== undefined) {\n            return maybeAlreadyAvailableStream;\n        }\n        return this.videoStreamFor(device);\n    }\n\n    private videoStreamFor(device: Device): Promise<MediaStream> {\n        return navigator.mediaDevices.getUserMedia({ video: { deviceId: device.deviceId } });\n    }\n\n    selectCamera(camera: Device) {\n        const alreadySelected = this.selectedCamera !== undefined\n            && this.selectedCamera.kind === camera.kind\n            && this.selectedCamera.groupId === camera.groupId\n            && this.selectedCamera.deviceId === camera.deviceId;\n        if (alreadySelected) {\n            console.log('already selected');\n            return;\n        }\n        this.selectedCamera = camera;\n        this.onCameraSelectionChangedListeners.forEach(listener => listener(this.selectedCamera));\n    }\n\n    clearCameraSelection () {\n        const cameraSelected = this.selectedCamera !== undefined;\n        if (cameraSelected) {\n            this.selectedCamera = undefined;\n            this.onCameraSelectionChangedListeners.forEach(listener => listener(this.selectedCamera));\n        }\n    }\n\n    addOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.add(listener);\n        listener(this.selectedCamera);\n    }\n\n    removeOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.delete(listener);\n    }\n\n    private close(stream: MediaStream | null): void {\n        if (stream) {\n            stream.getTracks().forEach(track => track.stop());\n        }\n    }\n}\n","import React from 'react';\nimport { Json } from './Json';\n\nexport type MediaStreamTrackViewProps = Pick<MediaStreamTrack, 'id' | 'enabled' | 'kind' | 'label' | 'muted' | 'readyState'> & { track: MediaStreamTrack }\n\nexport class MediaStreamTrackView extends React.Component<MediaStreamTrackViewProps> {\n    render() {\n        const track = this.props.track;\n        return (\n            <dl>\n                <dt>id</dt>\n                <dd>{this.props.id}</dd>\n                <dt>readyState</dt>\n                <dd>{this.props.readyState}</dd>\n                <dt>enabled</dt>\n                <dd>{String(this.props.enabled)}</dd>\n                <dt>kind</dt>\n                <dd>{this.props.kind}</dd>\n                <dt>label</dt>\n                <dd>{this.props.label}</dd>\n                <dt>muted</dt>\n                <dd>{String(this.props.muted)}</dd>\n                <dt>capabilities</dt>\n                <dd>\n                    <Json content={track.getCapabilities()}/>\n                </dd>\n                <dt>constraints</dt>\n                <dd>\n                    <Json content={track.getConstraints()}/>\n                </dd>\n                <dt>settings</dt>\n                <dd>\n                    <Json content={track.getSettings()}/>\n                </dd>\n            </dl>\n        );\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { MediaStreamTrackView } from './MediaStreamTrackView';\nimport { VideoElement } from './VideoElement';\n\nexport interface VideoViewProps {\n    title: string;\n}\n\ninterface VideoViewState {\n    source: MediaStream | null;\n}\n\nexport class VideoView extends React.Component<VideoViewProps, VideoViewState> {\n\n    constructor(props: VideoViewProps) {\n        super(props);\n        this.state = { source: null };\n    }\n\n    private handleStart = () => {\n        navigator.mediaDevices.getUserMedia({ video: true })\n            .then((stream: MediaStream) => {\n                this.setState({\n                    source: stream\n                });\n            }).catch((err: Error) => {\n            alert(err);\n        });\n    };\n\n    private handlePause = () => {\n        this.tracks().forEach(track => track.enabled = false);\n        this.triggerRender();\n    };\n\n    private handleContinue = () => {\n        this.tracks().forEach(track => track.enabled = true);\n        this.triggerRender();\n    };\n\n    private handleStop = () => {\n        this.tracks().forEach(track => track.stop());\n        this.triggerRender();\n    };\n\n    private tracks(): Array<MediaStreamTrack> {\n        const maybeStream = this.state.source;\n        if (null === maybeStream) {\n            return [];\n        }\n        return maybeStream.getTracks();\n    }\n\n    private handleDetach = () => {\n        this.setState({ source: null });\n    };\n\n    render() {\n        const topStyles: CSSProperties = {\n            display: 'flex'\n        };\n\n        const controlStyles: CSSProperties = {\n            display: 'flex',\n            flexDirection: 'column'\n        };\n\n        const tracks = this.tracks().map(track => {\n            return (<li key={track.id}>\n                <MediaStreamTrackView enabled={track.enabled} id={track.id} kind={track.kind} label={track.label} muted={track.muted} readyState={track.readyState} track={track}/>\n            </li>);\n        });\n        return (\n            <div style={topStyles}>\n                <h1>{this.props.title}</h1>\n                <div style={controlStyles}>\n                    <button onClick={this.handleStart}>start</button>\n                    <button onClick={this.handlePause}>pause</button>\n                    <button onClick={this.handleContinue}>continue</button>\n                    <button onClick={this.handleStop}>stop</button>\n                    <button onClick={this.handleDetach}>detach</button>\n                </div>\n                <VideoElement id=\"video-chat\" srcObject={this.state.source} autoPlay={true}/>\n                <div>\n                    <h2>tracks</h2>\n                    <ul>\n                        {tracks}\n                    </ul>\n                </div>\n            </div>\n        );\n    }\n\n    private triggerRender() {\n        this.setState(this.state);\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { BigScreen } from './BigScreen';\nimport { CameraPicker } from './CameraPicker';\nimport { Hide } from './Hide';\nimport { Json } from './Json';\nimport { Device, RecordingDirector } from './RecordingDirector';\nimport { VideoView } from './VideoView';\n\nexport interface CameraDemonstratorProps {\n    recordingDirector: RecordingDirector;\n}\n\nexport const fetchDevices = (recordingDirector: RecordingDirector) => {\n    navigator.mediaDevices.enumerateDevices()\n        .then(function (mediaDeviceInfos) {\n            const toDevice = (mediaDeviceInfo: MediaDeviceInfo): Device => {\n                return {\n                    groupId: mediaDeviceInfo.groupId,\n                    deviceId: mediaDeviceInfo.deviceId,\n                    label: mediaDeviceInfo.label,\n                    kind: mediaDeviceInfo.kind\n                };\n            };\n            recordingDirector.updateDevices(mediaDeviceInfos.map(toDevice));\n        }).catch(function (err) {\n            console.log(err.name + ': ' + err.message);\n        }\n    );\n};\n\nconst logDeviceInformation = () => {\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n        console.log(`there are ${devices.length} devices`);\n        const devicesString = devices.map(device => `${device.kind} ${device.label} (${device.groupId}:${device.deviceId})`).join('\\n');\n        console.log(devicesString);\n    }).catch((e) => console.log(e));\n};\n\nexport const CameraDemonstrator: React.FC<CameraDemonstratorProps> = (props) => {\n    const style: CSSProperties = {\n        display: 'flex'\n    };\n    const sidebarStyle: CSSProperties = {\n        display: 'flex',\n        flexDirection: 'column'\n    }\n    return (\n        <>\n            <div style={style}>\n                <div style={sidebarStyle}>\n                    <button onClick={logDeviceInformation}>log device information</button>\n                    <CameraPicker recordingDirector={props.recordingDirector}/>\n                </div>\n                <BigScreen recordingDirector={props.recordingDirector}/>\n            </div>\n            <Hide hide={true}>\n                <VideoView title={'one'}/>\n                <Json content={navigator.mediaDevices.getSupportedConstraints()}/>\n            </Hide>\n        </>\n    );\n};\n\nexport const setupCameraDemonstrator: () => React.FC = () => {\n    const recordingDirector = new RecordingDirector();\n    const updateDevices = () => fetchDevices(recordingDirector);\n    updateDevices();\n    navigator.mediaDevices.addEventListener('devicechange', updateDevices);\n    return () => {\n        return <CameraDemonstrator recordingDirector={recordingDirector}/>;\n    };\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { setupCameraDemonstrator } from './devices/camera/CameraDemonstrator';\n//import { formattedInputOne } from 'input/formatting/formatting-spike-one';\n//import { formattedInputTwo } from 'input/formatting/formatting-spike-two';\nimport * as serviceWorker from './serviceWorker';\n\nconst Demonstrator = setupCameraDemonstrator();\n\nconst renderApplication = () => {\n    ReactDOM.render(<div>\n        <Demonstrator/>\n    </div>, document.getElementById('root'));\n};\nrenderApplication();\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}