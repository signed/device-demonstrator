{"version":3,"sources":["devices/camera/VideoElement.tsx","devices/camera/BigScreen.tsx","devices/camera/CameraPicker.tsx","devices/camera/Hide.tsx","devices/camera/Json.tsx","devices/camera/RecordingDirector.ts","devices/camera/MediaStreamTrackView.tsx","devices/camera/VideoView.tsx","devices/camera/CameraDemonstrator.tsx","serviceWorker.ts","index.tsx"],"names":["VideoElement","srcObject","muted","rest","videoElement","useRef","useEffect","node","current","ref","BigScreen","props","handleVideoClicked","recordingDirector","clearCameraSelection","handleDeviceSelectionChange","device","closeExistingStream","setState","undefined","mediaStreamSubscription","videoStreamSubscriptionFor","stream","then","catch","streamError","state","this","addOnCameraSelectionChanged","removeOnCameraSelectionChanged","autoPlay","onClick","id","maybeSubscription","cancel","React","Component","CameraPreview","handleSelect","selectCamera","maybeStream","index","label","deviceId","groupId","width","CameraPicker","availableDevicesChanged","cur","forceReRender","handleShowPreview","showPreviews","handleHidePreview","addOnUpdateDevicesListener","removeOnUpdateDevicesListener","button","previews","cameras","map","key","style","display","flexDirection","Hide","hide","Fragment","children","Json","content","contentAsJsonString","JSON","stringify","doNothing","MediaStreamSubscription","subscriptionDetails","canceled","cancelSubscription","Promise","reject","SubscriptionLedger","subscriptionsByDevice","Map","entry","get","subscribers","Set","set","add","subscriberIdentifier","onNoMoreSubscribers","delete","size","RecordingDirector","onUpdateDevicesListeners","subscriptionLedger","devices","onCameraSelectionChangedListeners","selectedCamera","newDevices","splice","length","push","forEach","it","filter","kind","streamForDevice","uuid","addSubscriber","removeSubscriber","close","maybeAlreadyAvailableStream","streamFor","videoStreamFor","navigator","mediaDevices","enumerateDevices","devicesWithLabels","console","log","updateDevices","getUserMedia","video","camera","listener","getTracks","track","stop","MediaStreamTrackView","readyState","String","enabled","getCapabilities","getConstraints","getSettings","VideoView","handleStart","source","err","alert","handlePause","tracks","triggerRender","handleContinue","handleStop","handleDetach","title","logDeviceInformation","devicesString","join","e","CameraDemonstrator","getSupportedConstraints","Boolean","window","location","hostname","match","Demonstrator","mediaDeviceInfos","mediaDeviceInfo","name","message","fetchDevices","addEventListener","setupCameraDemonstrator","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.91fafe81.chunk.js","sourcesContent":["import React, { useEffect, useRef } from 'react';\n\nexport interface HTMLVideoElementProps extends React.VideoHTMLAttributes<HTMLVideoElement> {\n    srcObject: MediaStream | null;\n}\n\nexport const VideoElement: React.FC<HTMLVideoElementProps> = ({ srcObject = null, muted = false, ...rest }) => {\n    const videoElement = useRef<HTMLVideoElement>(null);\n    useEffect(() => {\n        const node = videoElement.current;\n        if (node === null) {\n            return;\n        }\n        if (node.srcObject !== srcObject) {\n            node.srcObject = srcObject;\n        }\n        if (node.muted !== muted) {\n            node.muted = muted;\n        }\n    }, [srcObject, muted]);\n    return <video {...rest} ref={videoElement}/>;\n};\n","import React from 'react';\nimport { Device, MediaStreamSubscription, RecordingDirector } from './RecordingDirector';\nimport { VideoElement } from './VideoElement';\n\nexport interface BigScreenProps {\n    recordingDirector: RecordingDirector;\n}\n\nexport interface BigScreenState {\n    device: Device | void;\n    stream: MediaStream | null;\n    mediaStreamSubscription: MediaStreamSubscription | undefined;\n    streamError: boolean;\n}\n\nexport class BigScreen extends React.Component<BigScreenProps, BigScreenState> {\n\n    constructor(props: BigScreenProps) {\n        super(props);\n        this.state = { streamError: false, stream: null, mediaStreamSubscription: undefined, device: undefined };\n    }\n\n    componentDidMount(): void {\n        this.props.recordingDirector.addOnCameraSelectionChanged(this.handleDeviceSelectionChange);\n    }\n\n    componentWillUnmount(): void {\n        this.props.recordingDirector.removeOnCameraSelectionChanged(this.handleDeviceSelectionChange);\n        this.closeExistingStream();\n        this.setState({ device: undefined, streamError: false });\n    }\n\n    render() {\n        if (this.state.device === undefined) {\n            return <div>No device selected</div>;\n        }\n        if (this.state.stream === null) {\n            return <div>Opening stream</div>;\n        }\n        return (\n            <div>\n                {<VideoElement srcObject={this.state.stream} autoPlay={true} onClick={this.handleVideoClicked}/>}\n                <div>{this.state.stream.id}</div>\n            </div>\n\n        );\n    }\n\n    private handleVideoClicked = () => {\n        this.props.recordingDirector.clearCameraSelection();\n    }\n\n    private handleDeviceSelectionChange = (device: Device | void): void => {\n        this.closeExistingStream();\n        this.setState({ device }, () => {\n            if (device === undefined) {\n                return;\n            }\n            const mediaStreamSubscription = this.props.recordingDirector.videoStreamSubscriptionFor(device);\n            this.setState({ mediaStreamSubscription });\n            mediaStreamSubscription.stream\n                .then(stream => this.setState({ stream }))\n                .catch(() => this.setState({ streamError: true }));\n        });\n    };\n\n    private closeExistingStream() {\n        const maybeSubscription = this.state.mediaStreamSubscription;\n        if (maybeSubscription !== undefined) {\n            maybeSubscription.cancel();\n            this.setState({ stream: null, mediaStreamSubscription: undefined });\n        }\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { Device, MediaStreamSubscription, RecordingDirector } from './RecordingDirector';\nimport { VideoElement } from './VideoElement';\n\nexport interface CameraPreviewProps {\n    recordingDirector: RecordingDirector;\n    device: Device;\n    index: number;\n}\n\nexport interface CameraPreviewState {\n    mediaStreamSubscription: MediaStreamSubscription | undefined\n    stream: MediaStream | null;\n    streamError: boolean;\n}\n\nexport class CameraPreview extends React.Component<CameraPreviewProps, CameraPreviewState> {\n\n    constructor(props: CameraPreviewProps) {\n        super(props);\n        this.state = { mediaStreamSubscription: undefined, streamError: false, stream: null };\n    }\n\n    componentDidMount(): void {\n        const mediaStreamSubscription = this.props.recordingDirector.videoStreamSubscriptionFor(this.props.device);\n        this.setState({ mediaStreamSubscription });\n        mediaStreamSubscription.stream\n            .then(stream => this.setState({ stream }))\n            .catch(() => this.setState({ streamError: true }));\n    }\n\n    componentWillUnmount(): void {\n        const maybeSubscription = this.state.mediaStreamSubscription;\n        if (maybeSubscription !== undefined) {\n            maybeSubscription.cancel();\n            this.setState({ stream: null, mediaStreamSubscription: undefined });\n        }\n    }\n\n    render() {\n        const maybeStream = this.state.stream;\n        const device = this.props.device;\n        return (\n            <div>\n                <h4>Camera {this.props.index}</h4>\n                <ul>\n                    <li>device label: {device.label}</li>\n                    <li>device id: {device.deviceId}</li>\n                    <li>group id: {device.groupId}</li>\n                    <li>stream id: {maybeStream?.id ?? 'no-stream'}</li>\n                </ul>\n                {<VideoElement onClick={this.handleSelect} width={150} srcObject={maybeStream} autoPlay={true}/>}\n            </div>\n        );\n    }\n\n    private handleSelect = () => {\n        this.props.recordingDirector.selectCamera(this.props.device);\n    };\n}\n\nexport interface CameraPickerProps {\n    recordingDirector: RecordingDirector\n}\n\nexport interface CameraPickerState {\n    showPreviews: boolean;\n    forceReRender: number;\n}\n\nexport class CameraPicker extends React.Component<CameraPickerProps, CameraPickerState> {\n\n    constructor(props: CameraPickerProps) {\n        super(props);\n        this.state = { showPreviews: false, forceReRender: 0 };\n    }\n\n    componentDidMount() {\n        this.props.recordingDirector.addOnUpdateDevicesListener(this.availableDevicesChanged);\n    }\n\n\n    private availableDevicesChanged = () => {\n        this.setState((cur) => ({\n            forceReRender: cur.forceReRender + 1\n        }));\n    };\n\n    componentWillUnmount() {\n        this.props.recordingDirector.removeOnUpdateDevicesListener(this.availableDevicesChanged);\n    }\n\n    render() {\n        const button = this.state.showPreviews ? <button onClick={this.handleHidePreview}>Hide Previews</button> : <button onClick={this.handleShowPreview}>Show Previews</button>;\n        const previews = this.state.showPreviews ? this.props.recordingDirector.cameras()\n            .map((device, index) => <CameraPreview key={device.deviceId} index={index} device={device} recordingDirector={this.props.recordingDirector}/>) : null;\n        const style: CSSProperties = {\n            display: 'flex',\n            flexDirection: 'column'\n        };\n        return (\n            <div style={style}>\n                {button}\n                {previews}\n            </div>\n        );\n    }\n\n    private handleShowPreview = () => {\n        this.setState({ showPreviews: true });\n    };\n\n    private handleHidePreview = () => {\n        this.setState({ showPreviews: false });\n    };\n}\n","import React from 'react';\n\nexport interface HideProps {\n    hide: boolean;\n}\n\nexport class Hide extends React.Component<HideProps> {\n    render(){\n        if (this.props.hide) {\n            return null;\n        }\n        return (\n            <React.Fragment>\n                {this.props.children}\n            </React.Fragment>\n        );\n    }\n}\n","import React from 'react';\n\ninterface JsonProps {\n    content: any;\n}\n\nexport const Json: React.FC<JsonProps> = ({ content}) => {\n    const contentAsJsonString = JSON.stringify(content, null, 2);\n    return <pre>{contentAsJsonString}</pre>\n};\n","import { uuid } from 'uuidv4';\n\nexport type Device = Pick<MediaDeviceInfo, 'groupId' | 'deviceId' | 'kind' | 'label'>;\n\nexport type OnCameraSelectionChangedListener = (newCamera: Device | void) => void;\nexport type OnUpdateDevicesListener = () => void;\n\ninterface SubscriptionDetails {\n    readonly device: Device;\n    readonly subscriberIdentifier: string;\n    stream: Promise<MediaStream>\n}\n\nconst doNothing = () => {\n};\n\nexport class MediaStreamSubscription {\n    private canceled = false;\n\n    constructor(\n        private readonly recordingDirector: RecordingDirector,\n        private readonly subscriptionDetails: SubscriptionDetails) {\n    }\n\n    get stream() {\n        if (this.canceled) {\n            return Promise.reject('subscription canceled');\n        }\n        return this.subscriptionDetails.stream;\n    }\n\n    cancel() {\n        this.recordingDirector.cancelSubscription(this.subscriptionDetails);\n        this.canceled = true;\n    }\n}\n\n\ninterface SubscriptionLedgerEntry {\n    subscribers: Set<string>;\n    stream: Promise<MediaStream>;\n}\n\nclass SubscriptionLedger {\n    private readonly subscriptionsByDevice: Map<string, SubscriptionLedgerEntry> = new Map();\n\n    addSubscriber(subscriptionDetails: SubscriptionDetails) {\n        const deviceId = subscriptionDetails.device.deviceId;\n        let entry = this.subscriptionsByDevice.get(deviceId);\n        if (entry === undefined) {\n            entry = { stream: subscriptionDetails.stream, subscribers: new Set<string>() };\n            this.subscriptionsByDevice.set(deviceId, entry);\n        }\n        entry.subscribers.add(subscriptionDetails.subscriberIdentifier);\n    }\n\n    removeSubscriber(subscriptionDetails: SubscriptionDetails, onNoMoreSubscribers: (stream: Promise<MediaStream>) => void = doNothing) {\n        const entry = this.subscriptionsByDevice.get(subscriptionDetails.device.deviceId);\n        if (entry === undefined) {\n            return;\n        }\n        entry.subscribers.delete(subscriptionDetails.subscriberIdentifier);\n        if (entry.subscribers.size === 0) {\n            this.subscriptionsByDevice.delete(subscriptionDetails.device.deviceId);\n            onNoMoreSubscribers(entry.stream);\n        }\n    }\n\n    streamFor(device: Device): Promise<MediaStream> | undefined {\n        const entry = this.subscriptionsByDevice.get(device.deviceId);\n        if (entry === undefined) {\n            return undefined;\n        }\n        return entry.stream;\n    }\n}\n\nexport class RecordingDirector {\n    private readonly onUpdateDevicesListeners = new Set<OnUpdateDevicesListener>()\n    private readonly subscriptionLedger = new SubscriptionLedger();\n    private readonly devices: Array<Device> = [];\n    private onCameraSelectionChangedListeners: Set<OnCameraSelectionChangedListener> = new Set<OnCameraSelectionChangedListener>();\n    private selectedCamera: Device | undefined;\n\n    updateDevices(newDevices: Array<Device>) {\n        this.devices.splice(0, this.devices.length);\n        this.devices.push(...newDevices);\n        this.onUpdateDevicesListeners.forEach(it => it());\n    }\n\n    cameras() {\n        return this.devices.filter(device => device.kind === 'videoinput').filter(device => 'default' !== device.label);\n    }\n\n    videoStreamSubscriptionFor(device: Device): MediaStreamSubscription {\n        let subscriptionDetails = {\n            device,\n            stream: this.streamForDevice(device),\n            subscriberIdentifier: uuid()\n        };\n        this.subscriptionLedger.addSubscriber(subscriptionDetails);\n        return new MediaStreamSubscription(this, subscriptionDetails);\n    }\n\n    cancelSubscription(subscriptionDetails: SubscriptionDetails): void {\n        this.subscriptionLedger.removeSubscriber(subscriptionDetails, (stream) => stream.then(this.close).catch(doNothing));\n    }\n\n    private streamForDevice(device: Device): Promise<MediaStream> {\n        const maybeAlreadyAvailableStream = this.subscriptionLedger.streamFor(device);\n        if (maybeAlreadyAvailableStream !== undefined) {\n            return maybeAlreadyAvailableStream;\n        }\n        return this.videoStreamFor(device).then((stream) => {\n            // resolve the label of the device after the permission was given.\n            // we are in the then clause, so we can assume the permission was given.\n            if (device.label === '') {\n                 navigator.mediaDevices.enumerateDevices().then((devices) => {\n                     const devicesWithLabels = devices.map(it => ({\n                        kind: it.kind,\n                        label: it.label,\n                        deviceId: it.deviceId,\n                        groupId: it.groupId\n                    }));\n                     console.log(devicesWithLabels);\n                    this.updateDevices(devicesWithLabels);\n                });\n\n            }\n            return stream;\n        });\n    }\n\n    private videoStreamFor(device: Device): Promise<MediaStream> {\n        return navigator.mediaDevices.getUserMedia({ video: { deviceId: device.deviceId } });\n    }\n\n    selectCamera(camera: Device) {\n        const alreadySelected = this.selectedCamera !== undefined\n            && this.selectedCamera.kind === camera.kind\n            && this.selectedCamera.groupId === camera.groupId\n            && this.selectedCamera.deviceId === camera.deviceId;\n        if (alreadySelected) {\n            console.log('already selected');\n            return;\n        }\n        this.selectedCamera = camera;\n        this.onCameraSelectionChangedListeners.forEach(listener => listener(this.selectedCamera));\n    }\n\n    clearCameraSelection() {\n        const cameraSelected = this.selectedCamera !== undefined;\n        if (cameraSelected) {\n            this.selectedCamera = undefined;\n            this.onCameraSelectionChangedListeners.forEach(listener => listener(this.selectedCamera));\n        }\n    }\n\n    addOnUpdateDevicesListener(listener: OnUpdateDevicesListener){\n        this.onUpdateDevicesListeners.add(listener);\n    }\n\n    removeOnUpdateDevicesListener(listener: OnUpdateDevicesListener){\n        this.onUpdateDevicesListeners.delete(listener)\n    }\n\n    addOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.add(listener);\n        listener(this.selectedCamera);\n    }\n\n    removeOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.delete(listener);\n    }\n\n    private close(stream: MediaStream | null): void {\n        if (stream) {\n            stream.getTracks().forEach(track => track.stop());\n        }\n    }\n}\n","import React from 'react';\nimport { Json } from './Json';\n\nexport type MediaStreamTrackViewProps = Pick<MediaStreamTrack, 'id' | 'enabled' | 'kind' | 'label' | 'muted' | 'readyState'> & { track: MediaStreamTrack }\n\nexport class MediaStreamTrackView extends React.Component<MediaStreamTrackViewProps> {\n    render() {\n        const track = this.props.track;\n        return (\n            <dl>\n                <dt>id</dt>\n                <dd>{this.props.id}</dd>\n                <dt>readyState</dt>\n                <dd>{this.props.readyState}</dd>\n                <dt>enabled</dt>\n                <dd>{String(this.props.enabled)}</dd>\n                <dt>kind</dt>\n                <dd>{this.props.kind}</dd>\n                <dt>label</dt>\n                <dd>{this.props.label}</dd>\n                <dt>muted</dt>\n                <dd>{String(this.props.muted)}</dd>\n                <dt>capabilities</dt>\n                <dd>\n                    <Json content={track.getCapabilities()}/>\n                </dd>\n                <dt>constraints</dt>\n                <dd>\n                    <Json content={track.getConstraints()}/>\n                </dd>\n                <dt>settings</dt>\n                <dd>\n                    <Json content={track.getSettings()}/>\n                </dd>\n            </dl>\n        );\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { MediaStreamTrackView } from './MediaStreamTrackView';\nimport { VideoElement } from './VideoElement';\n\nexport interface VideoViewProps {\n    title: string;\n}\n\ninterface VideoViewState {\n    source: MediaStream | null;\n}\n\nexport class VideoView extends React.Component<VideoViewProps, VideoViewState> {\n\n    constructor(props: VideoViewProps) {\n        super(props);\n        this.state = { source: null };\n    }\n\n    private handleStart = () => {\n        navigator.mediaDevices.getUserMedia({ video: true })\n            .then((stream: MediaStream) => {\n                this.setState({\n                    source: stream\n                });\n            }).catch((err: Error) => {\n            alert(err);\n        });\n    };\n\n    private handlePause = () => {\n        this.tracks().forEach(track => track.enabled = false);\n        this.triggerRender();\n    };\n\n    private handleContinue = () => {\n        this.tracks().forEach(track => track.enabled = true);\n        this.triggerRender();\n    };\n\n    private handleStop = () => {\n        this.tracks().forEach(track => track.stop());\n        this.triggerRender();\n    };\n\n    private tracks(): Array<MediaStreamTrack> {\n        const maybeStream = this.state.source;\n        if (null === maybeStream) {\n            return [];\n        }\n        return maybeStream.getTracks();\n    }\n\n    private handleDetach = () => {\n        this.setState({ source: null });\n    };\n\n    render() {\n        const topStyles: CSSProperties = {\n            display: 'flex'\n        };\n\n        const controlStyles: CSSProperties = {\n            display: 'flex',\n            flexDirection: 'column'\n        };\n\n        const tracks = this.tracks().map(track => {\n            return (<li key={track.id}>\n                <MediaStreamTrackView enabled={track.enabled} id={track.id} kind={track.kind} label={track.label} muted={track.muted} readyState={track.readyState} track={track}/>\n            </li>);\n        });\n        return (\n            <div style={topStyles}>\n                <h1>{this.props.title}</h1>\n                <div style={controlStyles}>\n                    <button onClick={this.handleStart}>start</button>\n                    <button onClick={this.handlePause}>pause</button>\n                    <button onClick={this.handleContinue}>continue</button>\n                    <button onClick={this.handleStop}>stop</button>\n                    <button onClick={this.handleDetach}>detach</button>\n                </div>\n                <VideoElement id=\"video-chat\" srcObject={this.state.source} autoPlay={true}/>\n                <div>\n                    <h2>tracks</h2>\n                    <ul>\n                        {tracks}\n                    </ul>\n                </div>\n            </div>\n        );\n    }\n\n    private triggerRender() {\n        this.setState(this.state);\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { BigScreen } from './BigScreen';\nimport { CameraPicker } from './CameraPicker';\nimport { Hide } from './Hide';\nimport { Json } from './Json';\nimport { Device, RecordingDirector } from './RecordingDirector';\nimport { VideoView } from './VideoView';\n\nexport interface CameraDemonstratorProps {\n    recordingDirector: RecordingDirector;\n}\n\nexport const fetchDevices = (recordingDirector: RecordingDirector) => {\n    navigator.mediaDevices.enumerateDevices()\n        .then(function (mediaDeviceInfos) {\n            const toDevice = (mediaDeviceInfo: MediaDeviceInfo): Device => {\n                return {\n                    groupId: mediaDeviceInfo.groupId,\n                    deviceId: mediaDeviceInfo.deviceId,\n                    label: mediaDeviceInfo.label,\n                    kind: mediaDeviceInfo.kind\n                };\n            };\n            recordingDirector.updateDevices(mediaDeviceInfos.map(toDevice));\n        }).catch(function (err) {\n            console.log(err.name + ': ' + err.message);\n        }\n    );\n};\n\nconst logDeviceInformation = () => {\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n        console.log(`there are ${devices.length} devices`);\n        const devicesString = devices.map(device => `${device.kind} ${device.label} (${device.groupId}:${device.deviceId})`).join('\\n');\n        console.log(devicesString);\n    }).catch((e) => console.log(e));\n};\n\nexport const CameraDemonstrator: React.FC<CameraDemonstratorProps> = (props) => {\n    const style: CSSProperties = {\n        display: 'flex'\n    };\n    const sidebarStyle: CSSProperties = {\n        display: 'flex',\n        flexDirection: 'column'\n    }\n    return (\n        <>\n            <div style={style}>\n                <div style={sidebarStyle}>\n                    <button onClick={logDeviceInformation}>log device information</button>\n                    <CameraPicker recordingDirector={props.recordingDirector}/>\n                </div>\n                <BigScreen recordingDirector={props.recordingDirector}/>\n            </div>\n            <Hide hide={true}>\n                <VideoView title={'one'}/>\n                <Json content={navigator.mediaDevices.getSupportedConstraints()}/>\n            </Hide>\n        </>\n    );\n};\n\nexport const setupCameraDemonstrator: () => React.FC = () => {\n    const recordingDirector = new RecordingDirector();\n    const updateDevices = () => fetchDevices(recordingDirector);\n    updateDevices();\n    navigator.mediaDevices.addEventListener('devicechange', updateDevices);\n    return () => {\n        return <CameraDemonstrator recordingDirector={recordingDirector}/>;\n    };\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { setupCameraDemonstrator } from './devices/camera/CameraDemonstrator';\n//import { formattedInputOne } from 'input/formatting/formatting-spike-one';\n//import { formattedInputTwo } from 'input/formatting/formatting-spike-two';\nimport * as serviceWorker from './serviceWorker';\n\nconst Demonstrator = setupCameraDemonstrator();\n\nconst renderApplication = () => {\n    ReactDOM.render(<div>\n        <Demonstrator/>\n    </div>, document.getElementById('root'));\n};\nrenderApplication();\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}