{"version":3,"sources":["Hide.tsx","VideoElement.tsx","BigScreen.tsx","CameraPicker.tsx","RecordingDirector.ts","Json.tsx","serviceWorker.ts","MediaStreamTrackView.tsx","VideoView.tsx","index.tsx"],"names":["Hide","this","props","hide","Fragment","children","React","Component","VideoElement","srcObject","muted","rest","videoElement","useRef","useEffect","node","current","ref","BigScreen","handleDeviceSelectionChange","device","closeExistingStream","setState","undefined","mediaStreamSubscription","recordingDirector","videoStreamSubscriptionFor","stream","then","catch","streamError","state","addOnCameraSelectionChanged","removeOnCameraSelectionChanged","autoPlay","id","maybeSubscription","cancel","CameraPreview","handleSelect","selectCamera","maybeStream","label","onClick","width","CameraPicker","handleShowPreview","showPreviews","handleHidePreview","button","previews","cameras","map","key","deviceId","style","display","flexDirection","doNothing","MediaStreamSubscription","subscriptionDetails","canceled","cancelSubscription","Promise","reject","SubscriptionLedger","subscriptionsByDevice","Map","entry","get","subscribers","Set","set","add","subscriberIdentifier","onNoMoreSubscribers","delete","size","RecordingDirector","subscriptionLedger","devices","onCameraSelectionChangedListeners","selectedCamera","newDevices","splice","length","push","filter","kind","streamForDevice","uuid","addSubscriber","removeSubscriber","close","maybeAlreadyAvailableStream","streamFor","videoStreamFor","navigator","mediaDevices","getUserMedia","video","camera","groupId","console","log","forEach","listener","getTracks","track","stop","Json","content","contentAsJsonString","JSON","stringify","Boolean","window","location","hostname","match","MediaStreamTrackView","readyState","String","enabled","getCapabilities","getConstraints","getSettings","VideoView","handleStart","source","err","alert","handlePause","tracks","triggerRender","handleContinue","handleStop","handleDetach","title","fetchDevices","enumerateDevices","mediaDeviceInfos","updateDevices","mediaDeviceInfo","name","message","addEventListener","ReactDOM","render","getSupportedConstraints","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.fd7ed5a9.chunk.js","sourcesContent":["import React from 'react';\n\nexport interface HideProps {\n    hide: boolean;\n}\n\nexport class Hide extends React.Component<HideProps> {\n    render(){\n        if (this.props.hide) {\n            return null;\n        }\n        return (\n            <React.Fragment>\n                {this.props.children}\n            </React.Fragment>\n        );\n    }\n}\n","import React, { useEffect, useRef } from 'react';\n\nexport interface HTMLVideoElementProps extends React.VideoHTMLAttributes<HTMLVideoElement> {\n    srcObject: MediaStream | null;\n}\n\nexport const VideoElement: React.FC<HTMLVideoElementProps> = ({ srcObject = null, muted = false, ...rest }) => {\n    const videoElement = useRef<HTMLVideoElement>(null);\n    useEffect(() => {\n        const node = videoElement.current;\n        if (node === null) {\n            return;\n        }\n        if (node.srcObject !== srcObject) {\n            node.srcObject = srcObject;\n        }\n        if (node.muted !== muted) {\n            node.muted = muted;\n        }\n    }, [srcObject, muted]);\n    return <video {...rest} ref={videoElement}/>;\n};\n","import React from 'react';\nimport { Device, MediaStreamSubscription, RecordingDirector } from './RecordingDirector';\nimport { VideoElement } from './VideoElement';\n\nexport interface BigScreenProps {\n    recordingDirector: RecordingDirector;\n}\n\nexport interface BigScreenState {\n    device: Device | void;\n    stream: MediaStream | null;\n    mediaStreamSubscription: MediaStreamSubscription | undefined;\n    streamError: boolean;\n}\n\nexport class BigScreen extends React.Component<BigScreenProps, BigScreenState> {\n\n    constructor(props: BigScreenProps) {\n        super(props);\n        this.state = { streamError: false, stream: null, mediaStreamSubscription: undefined, device: undefined };\n    }\n\n    componentDidMount(): void {\n        this.props.recordingDirector.addOnCameraSelectionChanged(this.handleDeviceSelectionChange);\n    }\n\n    componentWillUnmount(): void {\n        this.props.recordingDirector.removeOnCameraSelectionChanged(this.handleDeviceSelectionChange);\n        this.closeExistingStream();\n        this.setState({ device: undefined, streamError: false });\n    }\n\n    render() {\n        if (this.state.device === undefined) {\n            return <div>No device selected</div>;\n        }\n        if (this.state.stream === null) {\n            return <div>Opening stream</div>;\n        }\n        return (\n            <div>\n                {<VideoElement srcObject={this.state.stream} autoPlay={true}/>}\n                <div>{this.state.stream.id}</div>\n            </div>\n\n        );\n    }\n\n    private handleDeviceSelectionChange = (device: Device | void): void => {\n        this.closeExistingStream();\n        this.setState({ device }, () => {\n            if (device === undefined) {\n                return;\n            }\n            const mediaStreamSubscription = this.props.recordingDirector.videoStreamSubscriptionFor(device);\n            this.setState({ mediaStreamSubscription });\n            mediaStreamSubscription.stream\n                .then(stream => this.setState({ stream }))\n                .catch(() => this.setState({ streamError: true }));\n        });\n    };\n\n    private closeExistingStream() {\n        const maybeSubscription = this.state.mediaStreamSubscription;\n        if (maybeSubscription !== undefined) {\n            maybeSubscription.cancel();\n            this.setState({ stream: null, mediaStreamSubscription: undefined });\n        }\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { VideoElement } from './VideoElement';\nimport { Device, MediaStreamSubscription, RecordingDirector } from './RecordingDirector';\n\nexport interface CameraPreviewProps {\n    recordingDirector: RecordingDirector;\n    device: Device;\n}\n\nexport interface CameraPreviewState {\n    mediaStreamSubscription: MediaStreamSubscription | undefined\n    stream: MediaStream | null;\n    streamError: boolean;\n}\n\nexport class CameraPreview extends React.Component<CameraPreviewProps, CameraPreviewState> {\n\n    constructor(props: CameraPreviewProps) {\n        super(props);\n        this.state = { mediaStreamSubscription: undefined, streamError: false, stream: null };\n    }\n\n    componentDidMount(): void {\n        const mediaStreamSubscription = this.props.recordingDirector.videoStreamSubscriptionFor(this.props.device);\n        this.setState({ mediaStreamSubscription });\n        mediaStreamSubscription.stream\n            .then(stream => this.setState({ stream }))\n            .catch(() => this.setState({ streamError: true }));\n    }\n\n    componentWillUnmount(): void {\n        const maybeSubscription = this.state.mediaStreamSubscription;\n        if (maybeSubscription !== undefined) {\n            maybeSubscription.cancel();\n            this.setState({stream:null, mediaStreamSubscription: undefined})\n        }\n    }\n\n    render() {\n        const maybeStream = this.state.stream;\n        return (\n            <div>\n                <h4>{this.props.device.label}</h4>\n                {maybeStream !== null && <div>{maybeStream.id}</div>}\n                {this.state !== undefined && <VideoElement onClick={this.handleSelect} width={150} srcObject={maybeStream} autoPlay={true}/>}\n            </div>\n        );\n    }\n\n    private handleSelect = () => {\n        this.props.recordingDirector.selectCamera(this.props.device)\n    }\n}\n\nexport interface CameraPickerProps {\n    recordingDirector: RecordingDirector\n}\n\nexport interface CameraPickerState {\n    showPreviews: boolean;\n}\n\nexport class CameraPicker extends React.Component<CameraPickerProps, CameraPickerState> {\n\n    constructor(props: CameraPickerProps) {\n        super(props);\n        this.state = { showPreviews: false };\n    }\n\n    render() {\n        const button = this.state.showPreviews ? <button onClick={this.handleHidePreview}>Hide Previews</button> : <button onClick={this.handleShowPreview}>Show Previews</button>;\n        const previews = this.state.showPreviews ? this.props.recordingDirector.cameras().map(device => <CameraPreview key={device.deviceId} device={device} recordingDirector={this.props.recordingDirector}/>) : null;\n        const style: CSSProperties = {\n            display: 'flex',\n            flexDirection: 'column'\n        };\n        return (\n            <div style={style}>\n                {button}\n                {previews}\n            </div>\n        );\n    }\n\n    private handleShowPreview = () => {\n        this.setState({ showPreviews: true });\n    };\n\n    private handleHidePreview = () => {\n        this.setState({ showPreviews: false });\n    };\n}\n","import uuid from 'uuidv4';\n\nexport type Device = Pick<MediaDeviceInfo, 'groupId' | 'deviceId' | 'kind' | 'label'>;\n\nexport type OnCameraSelectionChangedListener = (newCamera: Device | void) => void;\n\ninterface SubscriptionDetails {\n    readonly device: Device;\n    readonly subscriberIdentifier: string;\n    stream: Promise<MediaStream>\n}\n\nconst doNothing = () => {\n};\n\nexport class MediaStreamSubscription {\n    private canceled = false;\n\n    constructor(\n        private readonly recordingDirector: RecordingDirector,\n        private readonly subscriptionDetails: SubscriptionDetails) {\n    }\n\n    get stream() {\n        if (this.canceled) {\n            return Promise.reject('subscription canceled');\n        }\n        return this.subscriptionDetails.stream;\n    }\n\n    cancel() {\n        this.recordingDirector.cancelSubscription(this.subscriptionDetails);\n        this.canceled = true;\n    }\n}\n\n\ninterface SubscriptionLedgerEntry {\n    subscribers: Set<string>;\n    stream: Promise<MediaStream>;\n}\n\nclass SubscriptionLedger {\n    private readonly subscriptionsByDevice: Map<string, SubscriptionLedgerEntry> = new Map();\n\n    addSubscriber(subscriptionDetails: SubscriptionDetails) {\n        const deviceId = subscriptionDetails.device.deviceId;\n        let entry = this.subscriptionsByDevice.get(deviceId);\n        if (entry === undefined) {\n            entry = { stream: subscriptionDetails.stream, subscribers: new Set<string>() };\n            this.subscriptionsByDevice.set(deviceId, entry)\n        }\n        entry.subscribers.add(subscriptionDetails.subscriberIdentifier)\n    }\n\n    removeSubscriber(subscriptionDetails: SubscriptionDetails, onNoMoreSubscribers: (stream: Promise<MediaStream>) => void = doNothing) {\n        const entry = this.subscriptionsByDevice.get(subscriptionDetails.device.deviceId);\n        if (entry === undefined) {\n            return;\n        }\n        entry.subscribers.delete(subscriptionDetails.subscriberIdentifier);\n        if (entry.subscribers.size === 0) {\n            this.subscriptionsByDevice.delete(subscriptionDetails.device.deviceId);\n            onNoMoreSubscribers(entry.stream);\n        }\n    }\n\n    streamFor(device: Device): Promise<MediaStream> | undefined {\n        const entry = this.subscriptionsByDevice.get(device.deviceId);\n        if (entry === undefined) {\n            return undefined;\n        }\n        return entry.stream;\n    }\n}\n\nexport class RecordingDirector {\n    private readonly subscriptionLedger = new SubscriptionLedger();\n    private readonly devices: Array<Device> = [];\n    private onCameraSelectionChangedListeners: Set<OnCameraSelectionChangedListener> = new Set<OnCameraSelectionChangedListener>();\n    private selectedCamera: Device | undefined;\n\n    updateDevices(newDevices: Array<Device>) {\n        this.devices.splice(0, this.devices.length);\n        this.devices.push(...newDevices);\n    }\n\n    cameras() {\n        return this.devices.filter(device => device.kind === 'videoinput').filter(device => 'default' !== device.label);\n    }\n\n    videoStreamSubscriptionFor(device: Device): MediaStreamSubscription {\n        let subscriptionDetails = {\n            device,\n            stream: this.streamForDevice(device),\n            subscriberIdentifier: uuid()\n        };\n        this.subscriptionLedger.addSubscriber(subscriptionDetails);\n        return new MediaStreamSubscription(this, subscriptionDetails);\n    }\n\n    cancelSubscription(subscriptionDetails: SubscriptionDetails): void {\n        this.subscriptionLedger.removeSubscriber(subscriptionDetails, (stream) => stream.then(this.close).catch(doNothing));\n    }\n\n    private streamForDevice(device: Device): Promise<MediaStream> {\n        const maybeAlreadyAvailableStream = this.subscriptionLedger.streamFor(device);\n        if (maybeAlreadyAvailableStream !== undefined) {\n            return maybeAlreadyAvailableStream;\n        }\n        return this.videoStreamFor(device);\n    }\n\n    private videoStreamFor(device: Device): Promise<MediaStream> {\n        return navigator.mediaDevices.getUserMedia({ video: { deviceId: device.deviceId } });\n    }\n\n    selectCamera(camera: Device) {\n        const alreadySelected = this.selectedCamera !== undefined\n            && this.selectedCamera.kind === camera.kind\n            && this.selectedCamera.groupId === camera.groupId\n            && this.selectedCamera.deviceId === camera.deviceId;\n        if (alreadySelected) {\n            console.log('already selected');\n            return;\n        }\n        this.selectedCamera = camera;\n        this.onCameraSelectionChangedListeners.forEach(listener => listener(this.selectedCamera));\n    }\n\n    addOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.add(listener);\n        listener(this.selectedCamera);\n    }\n\n    removeOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.delete(listener);\n    }\n\n    private close(stream: MediaStream | null): void {\n        if (stream) {\n            stream.getTracks().forEach(track => track.stop());\n        }\n    }\n}\n","import React from 'react';\n\ninterface JsonProps {\n    content: any;\n}\n\nexport const Json: React.FC<JsonProps> = ({ content}) => {\n    const contentAsJsonString = JSON.stringify(content, null, 2);\n    return <pre>{contentAsJsonString}</pre>\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport { Json } from './Json';\n\nexport type MediaStreamTrackViewProps = Pick<MediaStreamTrack, 'id' | 'enabled' | 'kind' | 'label' | 'muted' | 'readyState'> & { track: MediaStreamTrack }\n\nexport class MediaStreamTrackView extends React.Component<MediaStreamTrackViewProps> {\n    render() {\n        const track = this.props.track;\n        return (\n            <dl>\n                <dt>id</dt>\n                <dd>{this.props.id}</dd>\n                <dt>readyState</dt>\n                <dd>{this.props.readyState}</dd>\n                <dt>enabled</dt>\n                <dd>{String(this.props.enabled)}</dd>\n                <dt>kind</dt>\n                <dd>{this.props.kind}</dd>\n                <dt>label</dt>\n                <dd>{this.props.label}</dd>\n                <dt>muted</dt>\n                <dd>{String(this.props.muted)}</dd>\n                <dt>capabilities</dt>\n                <dd>\n                    <Json content={track.getCapabilities()}/>\n                </dd>\n                <dt>constraints</dt>\n                <dd>\n                    <Json content={track.getConstraints()}/>\n                </dd>\n                <dt>settings</dt>\n                <dd>\n                    <Json content={track.getSettings()}/>\n                </dd>\n            </dl>\n        );\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { MediaStreamTrackView } from './MediaStreamTrackView';\nimport { VideoElement } from './VideoElement';\n\nexport interface VideoViewProps {\n    title: string;\n}\n\ninterface VideoViewState {\n    source: MediaStream | null;\n}\n\nexport class VideoView extends React.Component<VideoViewProps, VideoViewState> {\n\n    constructor(props: VideoViewProps) {\n        super(props);\n        this.state = { source: null };\n    }\n\n    private handleStart = () => {\n        navigator.mediaDevices.getUserMedia({ video: true })\n            .then((stream: MediaStream) => {\n                this.setState({\n                    source: stream\n                });\n            }).catch((err: Error) => {\n            alert(err);\n        });\n    };\n\n    private handlePause = () => {\n        this.tracks().forEach(track => track.enabled = false);\n        this.triggerRender();\n    };\n\n    private handleContinue = () => {\n        this.tracks().forEach(track => track.enabled = true);\n        this.triggerRender();\n    };\n\n    private handleStop = () => {\n        this.tracks().forEach(track => track.stop());\n        this.triggerRender();\n    };\n\n    private tracks(): Array<MediaStreamTrack> {\n        const maybeStream = this.state.source;\n        if (null === maybeStream) {\n            return [];\n        }\n        return maybeStream.getTracks();\n    }\n\n    private handleDetach = () => {\n        this.setState({ source: null });\n    };\n\n    render() {\n        const topStyles: CSSProperties = {\n            display: 'flex'\n        };\n\n        const controlStyles: CSSProperties = {\n            display: 'flex',\n            flexDirection: 'column'\n        };\n\n        const tracks = this.tracks().map(track => {\n            return (<li key={track.id}>\n                <MediaStreamTrackView enabled={track.enabled} id={track.id} kind={track.kind} label={track.label} muted={track.muted} readyState={track.readyState} track={track}/>\n            </li>);\n        });\n        return (\n            <div style={topStyles}>\n                <h1>{this.props.title}</h1>\n                <div style={controlStyles}>\n                    <button onClick={this.handleStart}>start</button>\n                    <button onClick={this.handlePause}>pause</button>\n                    <button onClick={this.handleContinue}>continue</button>\n                    <button onClick={this.handleStop}>stop</button>\n                    <button onClick={this.handleDetach}>detach</button>\n                </div>\n                <VideoElement id=\"video-chat\" srcObject={this.state.source} autoPlay={true}/>\n                <div>\n                    <h2>tracks</h2>\n                    <ul>\n                        {tracks}\n                    </ul>\n                </div>\n            </div>\n        );\n    }\n\n    private triggerRender() {\n        this.setState(this.state);\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { Hide } from './Hide';\nimport { BigScreen } from './BigScreen';\nimport { CameraPicker } from './CameraPicker';\nimport { Device, RecordingDirector } from './RecordingDirector';\nimport { Json } from './Json';\nimport * as serviceWorker from './serviceWorker';\nimport { VideoView } from './VideoView';\n\nconst recordingDirector = new RecordingDirector();\n\nconst fetchDevices = () => {\n    navigator.mediaDevices.enumerateDevices()\n        .then(function (mediaDeviceInfos) {\n            const toDevice = (mediaDeviceInfo: MediaDeviceInfo): Device => {\n                return {\n                    groupId: mediaDeviceInfo.groupId,\n                    deviceId: mediaDeviceInfo.deviceId,\n                    label: mediaDeviceInfo.label,\n                    kind: mediaDeviceInfo.kind\n                };\n            };\n            recordingDirector.updateDevices(mediaDeviceInfos.map(toDevice));\n        }).catch(function (err) {\n            console.log(err.name + ': ' + err.message);\n        }\n    );\n};\n\nconst renderApplication = () => {\n    const style: CSSProperties = {\n        display: 'flex'\n    };\n    ReactDOM.render(<div>\n        <div style={style}>\n            <CameraPicker recordingDirector={recordingDirector}/>\n            <BigScreen recordingDirector={recordingDirector}/>\n        </div>\n        <Hide hide={true}>\n            <VideoView title={'one'}/>\n            <Json content={navigator.mediaDevices.getSupportedConstraints()}/>\n        </Hide>\n    </div>, document.getElementById('root'));\n};\n\nfetchDevices();\nnavigator.mediaDevices.addEventListener('devicechange', () => fetchDevices());\nrenderApplication();\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}