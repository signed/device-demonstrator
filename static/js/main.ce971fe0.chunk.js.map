{"version":3,"sources":["devices/camera/VideoElement.tsx","devices/camera/BigScreen.tsx","devices/camera/CameraPicker.tsx","devices/camera/Hide.tsx","devices/camera/Json.tsx","devices/camera/RecordingDirector.ts","devices/camera/MediaStreamTrackView.tsx","devices/camera/VideoView.tsx","devices/camera/CameraDemonstrator.tsx","serviceWorker.ts","index.tsx"],"names":["VideoElement","srcObject","muted","rest","videoElement","useRef","useEffect","node","current","ref","BigScreen","props","handleDeviceSelectionChange","device","closeExistingStream","setState","undefined","mediaStreamSubscription","recordingDirector","videoStreamSubscriptionFor","stream","then","catch","streamError","state","this","addOnCameraSelectionChanged","removeOnCameraSelectionChanged","autoPlay","id","maybeSubscription","cancel","React","Component","CameraPreview","handleSelect","selectCamera","maybeStream","index","label","deviceId","groupId","onClick","width","CameraPicker","handleShowPreview","showPreviews","handleHidePreview","button","previews","cameras","map","key","style","display","flexDirection","Hide","hide","Fragment","children","Json","content","contentAsJsonString","JSON","stringify","doNothing","MediaStreamSubscription","subscriptionDetails","canceled","cancelSubscription","Promise","reject","SubscriptionLedger","subscriptionsByDevice","Map","entry","get","subscribers","Set","set","add","subscriberIdentifier","onNoMoreSubscribers","delete","size","RecordingDirector","subscriptionLedger","devices","onCameraSelectionChangedListeners","selectedCamera","newDevices","splice","length","push","filter","kind","streamForDevice","uuid","addSubscriber","removeSubscriber","close","maybeAlreadyAvailableStream","streamFor","videoStreamFor","navigator","mediaDevices","getUserMedia","video","camera","console","log","forEach","listener","getTracks","track","stop","MediaStreamTrackView","readyState","String","enabled","getCapabilities","getConstraints","getSettings","VideoView","handleStart","source","err","alert","handlePause","tracks","triggerRender","handleContinue","handleStop","handleDetach","title","CameraDemonstrator","getSupportedConstraints","Boolean","window","location","hostname","match","Demonstrator","updateDevices","enumerateDevices","mediaDeviceInfos","mediaDeviceInfo","name","message","fetchDevices","addEventListener","setupCameraDemonstrator","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.ce971fe0.chunk.js","sourcesContent":["import React, { useEffect, useRef } from 'react';\n\nexport interface HTMLVideoElementProps extends React.VideoHTMLAttributes<HTMLVideoElement> {\n    srcObject: MediaStream | null;\n}\n\nexport const VideoElement: React.FC<HTMLVideoElementProps> = ({ srcObject = null, muted = false, ...rest }) => {\n    const videoElement = useRef<HTMLVideoElement>(null);\n    useEffect(() => {\n        const node = videoElement.current;\n        if (node === null) {\n            return;\n        }\n        if (node.srcObject !== srcObject) {\n            node.srcObject = srcObject;\n        }\n        if (node.muted !== muted) {\n            node.muted = muted;\n        }\n    }, [srcObject, muted]);\n    return <video {...rest} ref={videoElement}/>;\n};\n","import React from 'react';\nimport { Device, MediaStreamSubscription, RecordingDirector } from './RecordingDirector';\nimport { VideoElement } from './VideoElement';\n\nexport interface BigScreenProps {\n    recordingDirector: RecordingDirector;\n}\n\nexport interface BigScreenState {\n    device: Device | void;\n    stream: MediaStream | null;\n    mediaStreamSubscription: MediaStreamSubscription | undefined;\n    streamError: boolean;\n}\n\nexport class BigScreen extends React.Component<BigScreenProps, BigScreenState> {\n\n    constructor(props: BigScreenProps) {\n        super(props);\n        this.state = { streamError: false, stream: null, mediaStreamSubscription: undefined, device: undefined };\n    }\n\n    componentDidMount(): void {\n        this.props.recordingDirector.addOnCameraSelectionChanged(this.handleDeviceSelectionChange);\n    }\n\n    componentWillUnmount(): void {\n        this.props.recordingDirector.removeOnCameraSelectionChanged(this.handleDeviceSelectionChange);\n        this.closeExistingStream();\n        this.setState({ device: undefined, streamError: false });\n    }\n\n    render() {\n        if (this.state.device === undefined) {\n            return <div>No device selected</div>;\n        }\n        if (this.state.stream === null) {\n            return <div>Opening stream</div>;\n        }\n        return (\n            <div>\n                {<VideoElement srcObject={this.state.stream} autoPlay={true}/>}\n                <div>{this.state.stream.id}</div>\n            </div>\n\n        );\n    }\n\n    private handleDeviceSelectionChange = (device: Device | void): void => {\n        this.closeExistingStream();\n        this.setState({ device }, () => {\n            if (device === undefined) {\n                return;\n            }\n            const mediaStreamSubscription = this.props.recordingDirector.videoStreamSubscriptionFor(device);\n            this.setState({ mediaStreamSubscription });\n            mediaStreamSubscription.stream\n                .then(stream => this.setState({ stream }))\n                .catch(() => this.setState({ streamError: true }));\n        });\n    };\n\n    private closeExistingStream() {\n        const maybeSubscription = this.state.mediaStreamSubscription;\n        if (maybeSubscription !== undefined) {\n            maybeSubscription.cancel();\n            this.setState({ stream: null, mediaStreamSubscription: undefined });\n        }\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { VideoElement } from './VideoElement';\nimport { Device, MediaStreamSubscription, RecordingDirector } from './RecordingDirector';\n\nexport interface CameraPreviewProps {\n    recordingDirector: RecordingDirector;\n    device: Device;\n    index: number;\n}\n\nexport interface CameraPreviewState {\n    mediaStreamSubscription: MediaStreamSubscription | undefined\n    stream: MediaStream | null;\n    streamError: boolean;\n}\n\nexport class CameraPreview extends React.Component<CameraPreviewProps, CameraPreviewState> {\n\n    constructor(props: CameraPreviewProps) {\n        super(props);\n        this.state = { mediaStreamSubscription: undefined, streamError: false, stream: null };\n    }\n\n    componentDidMount(): void {\n        const mediaStreamSubscription = this.props.recordingDirector.videoStreamSubscriptionFor(this.props.device);\n        this.setState({ mediaStreamSubscription });\n        mediaStreamSubscription.stream\n            .then(stream => this.setState({ stream }))\n            .catch(() => this.setState({ streamError: true }));\n    }\n\n    componentWillUnmount(): void {\n        const maybeSubscription = this.state.mediaStreamSubscription;\n        if (maybeSubscription !== undefined) {\n            maybeSubscription.cancel();\n            this.setState({ stream: null, mediaStreamSubscription: undefined });\n        }\n    }\n\n    render() {\n        const maybeStream = this.state.stream;\n        const device = this.props.device;\n        return (\n            <div>\n                <h4>Camera {this.props.index}</h4>\n                <ul>\n                    <li>device label: {device.label}</li>\n                    <li>device id: {device.deviceId}</li>\n                    <li>group id: {device.groupId}</li>\n                    <li>stream id: {maybeStream?.id ?? 'no-stream'}</li>\n                </ul>\n                {<VideoElement onClick={this.handleSelect} width={150} srcObject={maybeStream} autoPlay={true}/>}\n            </div>\n        );\n    }\n\n    private handleSelect = () => {\n        this.props.recordingDirector.selectCamera(this.props.device);\n    };\n}\n\nexport interface CameraPickerProps {\n    recordingDirector: RecordingDirector\n}\n\nexport interface CameraPickerState {\n    showPreviews: boolean;\n}\n\nexport class CameraPicker extends React.Component<CameraPickerProps, CameraPickerState> {\n\n    constructor(props: CameraPickerProps) {\n        super(props);\n        this.state = { showPreviews: false };\n    }\n\n    render() {\n        const button = this.state.showPreviews ? <button onClick={this.handleHidePreview}>Hide Previews</button> : <button onClick={this.handleShowPreview}>Show Previews</button>;\n        const previews = this.state.showPreviews ? this.props.recordingDirector.cameras()\n            .map((device, index) => <CameraPreview key={device.deviceId} index={index} device={device} recordingDirector={this.props.recordingDirector}/>) : null;\n        const style: CSSProperties = {\n            display: 'flex',\n            flexDirection: 'column'\n        };\n        return (\n            <div style={style}>\n                {button}\n                {previews}\n            </div>\n        );\n    }\n\n    private handleShowPreview = () => {\n        this.setState({ showPreviews: true });\n    };\n\n    private handleHidePreview = () => {\n        this.setState({ showPreviews: false });\n    };\n}\n","import React from 'react';\n\nexport interface HideProps {\n    hide: boolean;\n}\n\nexport class Hide extends React.Component<HideProps> {\n    render(){\n        if (this.props.hide) {\n            return null;\n        }\n        return (\n            <React.Fragment>\n                {this.props.children}\n            </React.Fragment>\n        );\n    }\n}\n","import React from 'react';\n\ninterface JsonProps {\n    content: any;\n}\n\nexport const Json: React.FC<JsonProps> = ({ content}) => {\n    const contentAsJsonString = JSON.stringify(content, null, 2);\n    return <pre>{contentAsJsonString}</pre>\n};\n","import { uuid } from 'uuidv4';\n\nexport type Device = Pick<MediaDeviceInfo, 'groupId' | 'deviceId' | 'kind' | 'label'>;\n\nexport type OnCameraSelectionChangedListener = (newCamera: Device | void) => void;\n\ninterface SubscriptionDetails {\n    readonly device: Device;\n    readonly subscriberIdentifier: string;\n    stream: Promise<MediaStream>\n}\n\nconst doNothing = () => {\n};\n\nexport class MediaStreamSubscription {\n    private canceled = false;\n\n    constructor(\n        private readonly recordingDirector: RecordingDirector,\n        private readonly subscriptionDetails: SubscriptionDetails) {\n    }\n\n    get stream() {\n        if (this.canceled) {\n            return Promise.reject('subscription canceled');\n        }\n        return this.subscriptionDetails.stream;\n    }\n\n    cancel() {\n        this.recordingDirector.cancelSubscription(this.subscriptionDetails);\n        this.canceled = true;\n    }\n}\n\n\ninterface SubscriptionLedgerEntry {\n    subscribers: Set<string>;\n    stream: Promise<MediaStream>;\n}\n\nclass SubscriptionLedger {\n    private readonly subscriptionsByDevice: Map<string, SubscriptionLedgerEntry> = new Map();\n\n    addSubscriber(subscriptionDetails: SubscriptionDetails) {\n        const deviceId = subscriptionDetails.device.deviceId;\n        let entry = this.subscriptionsByDevice.get(deviceId);\n        if (entry === undefined) {\n            entry = { stream: subscriptionDetails.stream, subscribers: new Set<string>() };\n            this.subscriptionsByDevice.set(deviceId, entry)\n        }\n        entry.subscribers.add(subscriptionDetails.subscriberIdentifier)\n    }\n\n    removeSubscriber(subscriptionDetails: SubscriptionDetails, onNoMoreSubscribers: (stream: Promise<MediaStream>) => void = doNothing) {\n        const entry = this.subscriptionsByDevice.get(subscriptionDetails.device.deviceId);\n        if (entry === undefined) {\n            return;\n        }\n        entry.subscribers.delete(subscriptionDetails.subscriberIdentifier);\n        if (entry.subscribers.size === 0) {\n            this.subscriptionsByDevice.delete(subscriptionDetails.device.deviceId);\n            onNoMoreSubscribers(entry.stream);\n        }\n    }\n\n    streamFor(device: Device): Promise<MediaStream> | undefined {\n        const entry = this.subscriptionsByDevice.get(device.deviceId);\n        if (entry === undefined) {\n            return undefined;\n        }\n        return entry.stream;\n    }\n}\n\nexport class RecordingDirector {\n    private readonly subscriptionLedger = new SubscriptionLedger();\n    private readonly devices: Array<Device> = [];\n    private onCameraSelectionChangedListeners: Set<OnCameraSelectionChangedListener> = new Set<OnCameraSelectionChangedListener>();\n    private selectedCamera: Device | undefined;\n\n    updateDevices(newDevices: Array<Device>) {\n        this.devices.splice(0, this.devices.length);\n        this.devices.push(...newDevices);\n    }\n\n    cameras() {\n        return this.devices.filter(device => device.kind === 'videoinput').filter(device => 'default' !== device.label);\n    }\n\n    videoStreamSubscriptionFor(device: Device): MediaStreamSubscription {\n        let subscriptionDetails = {\n            device,\n            stream: this.streamForDevice(device),\n            subscriberIdentifier: uuid()\n        };\n        this.subscriptionLedger.addSubscriber(subscriptionDetails);\n        return new MediaStreamSubscription(this, subscriptionDetails);\n    }\n\n    cancelSubscription(subscriptionDetails: SubscriptionDetails): void {\n        this.subscriptionLedger.removeSubscriber(subscriptionDetails, (stream) => stream.then(this.close).catch(doNothing));\n    }\n\n    private streamForDevice(device: Device): Promise<MediaStream> {\n        const maybeAlreadyAvailableStream = this.subscriptionLedger.streamFor(device);\n        if (maybeAlreadyAvailableStream !== undefined) {\n            return maybeAlreadyAvailableStream;\n        }\n        return this.videoStreamFor(device);\n    }\n\n    private videoStreamFor(device: Device): Promise<MediaStream> {\n        return navigator.mediaDevices.getUserMedia({ video: { deviceId: device.deviceId } });\n    }\n\n    selectCamera(camera: Device) {\n        const alreadySelected = this.selectedCamera !== undefined\n            && this.selectedCamera.kind === camera.kind\n            && this.selectedCamera.groupId === camera.groupId\n            && this.selectedCamera.deviceId === camera.deviceId;\n        if (alreadySelected) {\n            console.log('already selected');\n            return;\n        }\n        this.selectedCamera = camera;\n        this.onCameraSelectionChangedListeners.forEach(listener => listener(this.selectedCamera));\n    }\n\n    addOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.add(listener);\n        listener(this.selectedCamera);\n    }\n\n    removeOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.delete(listener);\n    }\n\n    private close(stream: MediaStream | null): void {\n        if (stream) {\n            stream.getTracks().forEach(track => track.stop());\n        }\n    }\n}\n","import React from 'react';\nimport { Json } from './Json';\n\nexport type MediaStreamTrackViewProps = Pick<MediaStreamTrack, 'id' | 'enabled' | 'kind' | 'label' | 'muted' | 'readyState'> & { track: MediaStreamTrack }\n\nexport class MediaStreamTrackView extends React.Component<MediaStreamTrackViewProps> {\n    render() {\n        const track = this.props.track;\n        return (\n            <dl>\n                <dt>id</dt>\n                <dd>{this.props.id}</dd>\n                <dt>readyState</dt>\n                <dd>{this.props.readyState}</dd>\n                <dt>enabled</dt>\n                <dd>{String(this.props.enabled)}</dd>\n                <dt>kind</dt>\n                <dd>{this.props.kind}</dd>\n                <dt>label</dt>\n                <dd>{this.props.label}</dd>\n                <dt>muted</dt>\n                <dd>{String(this.props.muted)}</dd>\n                <dt>capabilities</dt>\n                <dd>\n                    <Json content={track.getCapabilities()}/>\n                </dd>\n                <dt>constraints</dt>\n                <dd>\n                    <Json content={track.getConstraints()}/>\n                </dd>\n                <dt>settings</dt>\n                <dd>\n                    <Json content={track.getSettings()}/>\n                </dd>\n            </dl>\n        );\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { MediaStreamTrackView } from './MediaStreamTrackView';\nimport { VideoElement } from './VideoElement';\n\nexport interface VideoViewProps {\n    title: string;\n}\n\ninterface VideoViewState {\n    source: MediaStream | null;\n}\n\nexport class VideoView extends React.Component<VideoViewProps, VideoViewState> {\n\n    constructor(props: VideoViewProps) {\n        super(props);\n        this.state = { source: null };\n    }\n\n    private handleStart = () => {\n        navigator.mediaDevices.getUserMedia({ video: true })\n            .then((stream: MediaStream) => {\n                this.setState({\n                    source: stream\n                });\n            }).catch((err: Error) => {\n            alert(err);\n        });\n    };\n\n    private handlePause = () => {\n        this.tracks().forEach(track => track.enabled = false);\n        this.triggerRender();\n    };\n\n    private handleContinue = () => {\n        this.tracks().forEach(track => track.enabled = true);\n        this.triggerRender();\n    };\n\n    private handleStop = () => {\n        this.tracks().forEach(track => track.stop());\n        this.triggerRender();\n    };\n\n    private tracks(): Array<MediaStreamTrack> {\n        const maybeStream = this.state.source;\n        if (null === maybeStream) {\n            return [];\n        }\n        return maybeStream.getTracks();\n    }\n\n    private handleDetach = () => {\n        this.setState({ source: null });\n    };\n\n    render() {\n        const topStyles: CSSProperties = {\n            display: 'flex'\n        };\n\n        const controlStyles: CSSProperties = {\n            display: 'flex',\n            flexDirection: 'column'\n        };\n\n        const tracks = this.tracks().map(track => {\n            return (<li key={track.id}>\n                <MediaStreamTrackView enabled={track.enabled} id={track.id} kind={track.kind} label={track.label} muted={track.muted} readyState={track.readyState} track={track}/>\n            </li>);\n        });\n        return (\n            <div style={topStyles}>\n                <h1>{this.props.title}</h1>\n                <div style={controlStyles}>\n                    <button onClick={this.handleStart}>start</button>\n                    <button onClick={this.handlePause}>pause</button>\n                    <button onClick={this.handleContinue}>continue</button>\n                    <button onClick={this.handleStop}>stop</button>\n                    <button onClick={this.handleDetach}>detach</button>\n                </div>\n                <VideoElement id=\"video-chat\" srcObject={this.state.source} autoPlay={true}/>\n                <div>\n                    <h2>tracks</h2>\n                    <ul>\n                        {tracks}\n                    </ul>\n                </div>\n            </div>\n        );\n    }\n\n    private triggerRender() {\n        this.setState(this.state);\n    }\n}\n","import React, { CSSProperties } from 'react';\nimport { BigScreen } from './BigScreen';\nimport { CameraPicker } from './CameraPicker';\nimport { Hide } from './Hide';\nimport { Json } from './Json';\nimport { Device, RecordingDirector } from './RecordingDirector';\nimport { VideoView } from './VideoView';\n\nexport interface CameraDemonstratorProps {\n    recordingDirector: RecordingDirector;\n}\n\nexport const fetchDevices = (recordingDirector: RecordingDirector) => {\n    navigator.mediaDevices.enumerateDevices()\n        .then(function (mediaDeviceInfos) {\n            const toDevice = (mediaDeviceInfo: MediaDeviceInfo): Device => {\n                return {\n                    groupId: mediaDeviceInfo.groupId,\n                    deviceId: mediaDeviceInfo.deviceId,\n                    label: mediaDeviceInfo.label,\n                    kind: mediaDeviceInfo.kind\n                };\n            };\n            recordingDirector.updateDevices(mediaDeviceInfos.map(toDevice));\n        }).catch(function (err) {\n            console.log(err.name + ': ' + err.message);\n        }\n    );\n};\n\n\nexport const CameraDemonstrator: React.FC<CameraDemonstratorProps> = (props) => {\n    const style: CSSProperties = {\n        display: 'flex'\n    };\n    return (\n        <>\n            <div style={style}>\n                <CameraPicker recordingDirector={props.recordingDirector}/>\n                <BigScreen recordingDirector={props.recordingDirector}/>\n            </div>\n            <Hide hide={true}>\n                <VideoView title={'one'}/>\n                <Json content={navigator.mediaDevices.getSupportedConstraints()}/>\n            </Hide>\n        </>\n    );\n};\n\nexport const setupCameraDemonstrator: () => React.FC = () => {\n    const recordingDirector = new RecordingDirector();\n    const updateDevices = () => fetchDevices(recordingDirector);\n    updateDevices();\n    navigator.mediaDevices.addEventListener('devicechange', updateDevices);\n    return () => {\n        return <CameraDemonstrator recordingDirector={recordingDirector}/>;\n    }\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { setupCameraDemonstrator } from './devices/camera/CameraDemonstrator';\n//import { formattedInputOne } from 'input/formatting/formatting-spike-one';\n//import { formattedInputTwo } from 'input/formatting/formatting-spike-two';\nimport * as serviceWorker from './serviceWorker';\n\nconst Demonstrator = setupCameraDemonstrator();\n\nconst renderApplication = () => {\n    ReactDOM.render(<div>\n        <Demonstrator/>\n    </div>, document.getElementById('root'));\n};\nrenderApplication();\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}