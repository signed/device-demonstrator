{"version":3,"sources":["devices/camera/Hide.tsx","devices/test-rig/Json.tsx","devices/test-rig/ErrorView.tsx","devices/test-rig/MediaStreamTrackView.tsx","devices/VideoElement.tsx","devices/test-rig/StreamView.tsx","devices/test-rig/Scenarios.ts","devices/test-rig/test-rig.tsx","devices/camera/DeviceDemonstratorContext.ts","devices/camera/BigScreen.tsx","devices/camera/CameraPicker.tsx","devices/camera/RecordingDirector.ts","devices/camera/CameraDemonstrator.tsx","index.tsx"],"names":["Hide","props","hide","Fragment","children","Json","content","contentAsJsonString","JSON","stringify","ErrorView","error","name","MediaStreamTrackView","track","capabilities","getCapabilities","id","readyState","String","enabled","kind","label","muted","getConstraints","getSettings","VideoElement","srcObject","rest","videoElement","useRef","useEffect","node","current","ref","StreamView","stream","useState","forceRender","triggerRender","prev","tracks","getTracks","tracksNode","map","key","style","display","flexDirection","onClick","forEach","stop","autoPlay","active","mediaStream","input","promise","a","success","messages","noDeviceWithDeviceId","summary","description","constraints","audio","deviceId","expected","checks","what","predicate","length","existingDevice","video","passUndefined","undefined","err","TypeError","toString","message","scenarios","result","Map","set","collectScenarios","reconstructPromiseFrom","Error","Promise","reject","resolve","TestRig","selectedScenario","setSelectedScenario","constraintsAsString","setConstraintsAsString","parseError","setParseError","setConstraints","getUserMediaResult","setGetUserMediaResult","results","setResults","parsedConstraints","parse","e","scenarioConstrains","get","scenarioConstraintsAsString","first","Array","from","keys","handleRunChecks","scenario","check","details","all","onChange","target","value","navigator","mediaDevices","getUserMedia","then","catch","disabled","checkIndex","messagesView","messageIndex","MediaStream","getSupportedConstraints","Context","React","createContext","useRecordingDirector","maybe","useContext","recordingDirector","useVideoStreamFrom","device","streamError","state","setState","mediaStreamSubscription","videoStreamSubscriptionFor","onDeviceRemoved","cancel","BigScreen","setDevice","handleDeviceSelectionChange","addOnCameraSelectionChanged","removeOnCameraSelectionChanged","clearCameraSelection","CameraPreview","index","streamAvailable","groupId","selectCamera","width","CameraPicker","showPreviews","forceReRender","availableDevicesChanged","cur","addOnUpdateDevicesListener","removeOnUpdateDevicesListener","button","previews","cameras","doNothing","DefaultMediaStreamSubscription","subscriptionDetails","_onDeviceRemoved","_canceled","_deviceRemoved","listener","this","cancelSubscription","SubscriptionLedger","subscriptionsByDevice","subscription","creator","maybeValue","getOrAdd","deviceIdentifier","subscriptions","subscriptionIdentifier","removedDeviceIds","entries","filter","d","includes","ledger","values","reduce","concat","onNoMoreSubscribers","entry","delete","size","RecordingDirector","onUpdateDevicesListeners","Set","subscriptionLedger","devices","onCameraSelectionChangedListeners","selectedCamera","newDevices","availableDevicesId","dev","splice","push","it","subscriptionsTo","sub","deviceRemoved","streamForDevice","uuid","addSubscriber","removeSubscriber","close","maybeAlreadyAvailableStream","streamFor","videoStreamFor","enumerateDevices","devicesWithLabels","console","log","updateDevices","camera","add","logDeviceInformation","devicesString","join","CameraDemonstrator","showCameraPicker","setShowCameraPicker","Demonstrator","mediaDeviceInfos","mediaDeviceInfo","fetchDevices","addEventListener","Provider","setupCameraDemonstrator","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.4709a79a.chunk.js","sourcesContent":["import React from 'react';\n\nexport interface HideProps {\n    hide: boolean;\n}\n\nexport const Hide: React.FC<HideProps> = (props) => {\n    if (props.hide) {\n        return null;\n    }\n    return <React.Fragment>\n        {props.children}\n    </React.Fragment>;\n};\n","import React from 'react';\n\ninterface JsonProps {\n    content: any;\n}\n\nexport const Json: React.FC<JsonProps> = ({ content}) => {\n    const contentAsJsonString = JSON.stringify(content, null, 2);\n    return <pre>{contentAsJsonString}</pre>\n};\n","import React from 'react';\nimport { Json } from './Json';\n\nexport const ErrorView: React.FC<{ error: Error }> = (props) => {\n    const { error } = props;\n    return <div>\n        <h1>{error.name}</h1>\n        <Json content={error}/>\n    </div>\n};\n","import React from 'react';\nimport { Json } from './Json';\n\nexport type MediaStreamTrackViewProps = Pick<MediaStreamTrack, 'id' | 'enabled' | 'kind' | 'label' | 'muted' | 'readyState'> & { track: MediaStreamTrack }\n\nexport const MediaStreamTrackView: React.FC<MediaStreamTrackViewProps> = (props) => {\n    const { track } = props;\n    const capabilities = track.getCapabilities ? track.getCapabilities(): 'track.getCapabilities does not exist';\n    return (\n        <dl>\n            <dt>id</dt>\n            <dd>{props.id}</dd>\n            <dt>readyState</dt>\n            <dd>{props.readyState}</dd>\n            <dt>enabled</dt>\n            <dd>{String(props.enabled)}</dd>\n            <dt>kind</dt>\n            <dd>{props.kind}</dd>\n            <dt>label</dt>\n            <dd>{props.label}</dd>\n            <dt>muted</dt>\n            <dd>{String(props.muted)}</dd>\n            <dt>capabilities</dt>\n            <dd>\n                <Json content={capabilities}/>\n            </dd>\n            <dt>constraints</dt>\n            <dd>\n                <Json content={track.getConstraints()}/>\n            </dd>\n            <dt>settings</dt>\n            <dd>\n                <Json content={track.getSettings()}/>\n            </dd>\n        </dl>\n    );\n};\n","import React, { useEffect, useRef } from 'react';\n\nexport interface HTMLVideoElementProps extends React.VideoHTMLAttributes<HTMLVideoElement> {\n    srcObject: MediaStream | null;\n}\n\nexport const VideoElement: React.FC<HTMLVideoElementProps> = ({ srcObject = null, muted = false, ...rest }) => {\n    const videoElement = useRef<HTMLVideoElement>(null);\n    useEffect(() => {\n        const node = videoElement.current;\n        if (node === null) {\n            return;\n        }\n        if (node.srcObject !== srcObject) {\n            node.srcObject = srcObject;\n        }\n        if (node.muted !== muted) {\n            node.muted = muted;\n        }\n    }, [srcObject, muted]);\n    return <video {...rest} ref={videoElement}/>;\n};\n","import React, { CSSProperties, useState } from 'react';\nimport { MediaStreamTrackView } from './MediaStreamTrackView';\nimport { VideoElement } from '../VideoElement';\n\nexport interface StreamViewProps {\n    stream: MediaStream | null\n}\n\nexport const StreamView: React.FC<StreamViewProps> = (props) => {\n    const { stream } = props;\n    const [_, forceRender] = useState(true);\n\n    const triggerRender = () => {\n        forceRender(prev => !prev);\n    };\n\n    const tracks = (): Array<MediaStreamTrack> => {\n        const maybeStream = stream;\n        if (null === maybeStream) {\n            return [];\n        }\n        return maybeStream.getTracks();\n    };\n\n    const handlePause = () => {\n        tracks().forEach(track => track.enabled = false);\n        triggerRender();\n    };\n\n    const handleContinue = () => {\n        tracks().forEach(track => track.enabled = true);\n        triggerRender();\n    };\n\n    const handleStop = () => {\n        tracks().forEach(track => track.stop());\n        triggerRender();\n    };\n\n    const topStyles: CSSProperties = {\n        display: 'flex'\n    };\n\n    const controlStyles: CSSProperties = {\n        display: 'flex',\n        flexDirection: 'column'\n    };\n\n    const tracksNode = tracks().map(track => {\n        return (<li key={track.id}>\n            <MediaStreamTrackView enabled={track.enabled} id={track.id} kind={track.kind} label={track.label} muted={track.muted} readyState={track.readyState} track={track}/>\n        </li>);\n    });\n    return (\n        <div style={topStyles}>\n            <h1>Scenario View</h1>\n            <div style={controlStyles}>\n                <button onClick={handlePause}>pause</button>\n                <button onClick={handleContinue}>continue</button>\n                <button onClick={handleStop}>stop</button>\n            </div>\n            <VideoElement id=\"video-chat\" srcObject={stream} autoPlay={true}/>\n            {stream && <div>\n                <h2>stream</h2>\n                <ul>\n                    <li>id: {stream.id}</li>\n                    <li>active: {JSON.stringify(stream.active)}</li>\n                </ul>\n                <h2>tracks</h2>\n                <ul>\n                    {tracksNode}\n                </ul>\n            </div>}\n        </div>\n    );\n};\n","export type MediaStreamCheckResult = { success: boolean, messages?: Array<string> }\ntype MediaStreamPredicate = (mediaStream: MediaStream) => MediaStreamCheckResult\ntype ErrorPredicate = (error: Error) => MediaStreamCheckResult\ntype MediaStreamPromisePredicate = (mediaStream: Promise<MediaStream>) => Promise<MediaStreamCheckResult>\n\nconst mediaStream: (input: MediaStreamPredicate) => MediaStreamPromisePredicate = (input: MediaStreamPredicate) => {\n    return async (promise: Promise<MediaStream>) => input(await promise);\n};\nconst error: (input: ErrorPredicate) => MediaStreamPromisePredicate = (input: ErrorPredicate) => {\n    return async (promise: Promise<MediaStream>) => {\n        try {\n            await promise;\n            return { success: false, messages: ['expected a rejected promise'] };\n        } catch (e) {\n            return input(e);\n        }\n    };\n};\n\n\ntype MediaStreamCheck = {\n    what: string;\n    predicate: MediaStreamPromisePredicate\n}\n\ninterface Expected {\n    description: string;\n    checks: MediaStreamCheck[]\n}\n\nexport interface Scenario {\n    summary: string;\n    description: string;\n    constraints?: MediaStreamConstraints,\n    expected: Expected\n}\n\nexport const noDeviceWithDeviceId: Scenario = {\n    summary: 'bogus device id',\n    description: 'the constraint contains a deviceId that no device has',\n    constraints: { audio: { deviceId: 'bogus' } },\n    expected: {\n        description: 'fallback to any other audio device',\n        checks: [\n            {\n                what: 'stream is active',\n                predicate: mediaStream((stream) => {\n                    const success = stream.active;\n                    return { success };\n                })\n            }\n            , {\n                what: 'stream has an id',\n                predicate: mediaStream((stream) => {\n                    const success = stream.id.length > 0;\n                    return { success };\n                })\n            }\n        ]\n    }\n};\n\nexport const existingDevice: Scenario = {\n    summary: 'existing device',\n    description: 'the constraint contains a deviceId of an existing device',\n    constraints: { video: { deviceId: '77df7c3d3f24890c51364752fb295895fbebdc821755f6706f5bcd06e6e63269' } },\n    expected: {\n        description: 'tbd',\n        checks: []\n    }\n};\n\nexport const passUndefined: Scenario = {\n    summary: 'undefined constraints',\n    description: 'pass undefined as constraints',\n    constraints: undefined,\n    expected: {\n        description: 'reject and communicate that at least one constrain has to be present',\n        checks: [\n            {\n                what: 'TypeError',\n                predicate: error((err) => {\n                    const success = err instanceof TypeError;\n                    const messages = [`got: ${err.toString()}`];\n                    return { success, messages };\n                })\n            }, {\n                what: 'error message',\n                predicate: error((err) => {\n                    const expected = `Failed to execute 'getUserMedia' on 'MediaDevices': At least one of audio and video must be requested`;\n                    const success = err.message === expected;\n                    const messages = [\n                        `expected: ${expected}`,\n                        `got: '${err.message}'`\n                    ];\n\n                    return { success, messages };\n                })\n            }\n        ]\n    }\n};\n\nconst collectScenarios = () => {\n    const result = new Map<string, Scenario>();\n    result.set(noDeviceWithDeviceId.summary, noDeviceWithDeviceId);\n    result.set(existingDevice.summary, existingDevice);\n    result.set(passUndefined.summary, passUndefined);\n    return result;\n};\n\nexport const scenarios = collectScenarios();\n\n","import React, { useEffect, useState } from 'react';\nimport { Hide } from '../camera/Hide';\nimport { ErrorView } from './ErrorView';\nimport { Json } from './Json';\nimport { StreamView } from './StreamView';\nimport { MediaStreamCheckResult, scenarios } from './Scenarios';\n\nexport interface Result {\n    what: string;\n    details: MediaStreamCheckResult;\n}\n\ntype GetUserMediaResult = MediaStream | Error\n\nconst reconstructPromiseFrom = (result: GetUserMediaResult): Promise<MediaStream> => {\n    if (result instanceof Error) {\n        return Promise.reject(result);\n    }\n    return Promise.resolve(result);\n};\n\nexport const TestRig: React.FC<{}> = () => {\n    const [selectedScenario, setSelectedScenario] = useState<string>();\n    const [constraintsAsString, setConstraintsAsString] = useState('');\n    const [parseError, setParseError] = useState<boolean>(false);\n    const [constraints, setConstraints] = useState<MediaStreamConstraints>();\n    const [getUserMediaResult, setGetUserMediaResult] = useState<GetUserMediaResult | null>(null);\n    const [results, setResults] = useState<Result[]>([]);\n\n    useEffect(() => {\n        try {\n            const parsedConstraints = (constraintsAsString === 'undefined') ? undefined : JSON.parse(constraintsAsString);\n            setConstraints(parsedConstraints);\n            setParseError(false);\n        } catch (e) {\n            setParseError(true);\n        }\n    }, [constraintsAsString, setParseError]);\n\n    useEffect(() => {\n        if (selectedScenario === undefined) {\n            const first = Array.from(scenarios.keys())[0];\n            setSelectedScenario(first);\n            return;\n        }\n        const scenarioConstrains = scenarios.get(selectedScenario)?.constraints;\n        const scenarioConstraintsAsString = scenarioConstrains === undefined ? 'undefined' : JSON.stringify(scenarioConstrains, null, 2);\n        setConstraintsAsString(scenarioConstraintsAsString);\n    }, [selectedScenario]);\n\n    useEffect(() => {\n        setResults(() => []);\n    }, [selectedScenario]);\n\n    const handleStart = () => {\n        navigator.mediaDevices.getUserMedia(constraints)\n            .then((stream: MediaStream) => setGetUserMediaResult(() => stream))\n            .catch((err: Error) => setGetUserMediaResult(() => err));\n    };\n\n    const handleDetach = () => {\n        setGetUserMediaResult(null);\n    };\n\n    const handleRunChecks = async () => {\n        const scenario = scenarios.get(selectedScenario ?? '');\n        if (scenario === undefined || getUserMediaResult === null) {\n            return;\n        }\n        const results = scenario.expected.checks.map(async check => {\n            let result: MediaStreamCheckResult;\n            try {\n                result = await check.predicate(reconstructPromiseFrom(getUserMediaResult));\n            } catch (e) {\n                const messages = [`check threw exception ${e.toString()}`];\n                result = { success: false, messages };\n            }\n\n            return ({\n                what: check.what,\n                details: result\n            });\n        });\n\n        setResults(await Promise.all(results));\n    };\n\n    const handleClearChecks = () => {\n        setResults(() => []);\n    };\n\n    return <div>\n        <h1 key={'test-rig'}>Test Rig{parseError ? ' (parse error)' : ''}</h1>\n        <select name=\"scenarios\" onChange={(e) => setSelectedScenario(e.target.value)}>\n            {Array.from(scenarios.keys()).map(summary => <option value={summary} key={summary}>{summary}</option>)}\n        </select>\n        <textarea value={constraintsAsString} onChange={(e) => setConstraintsAsString(e.target.value)}/>\n        <button onClick={handleStart}>start</button>\n        <button disabled={getUserMediaResult === null} onClick={handleRunChecks}>run checks</button>\n        <button onClick={handleClearChecks}>clear checks</button>\n        <button onClick={handleDetach}>detach</button>\n        <ul key={'results'}>\n            {results.map((result, checkIndex) => {\n                const success = result.details.success ? '✅' : '❌';\n                const messages = result.details.messages ?? [];\n\n                const showMessages = !result.details.success && messages.length !== 0;\n                const messagesView = showMessages ? <ul key={`message ${checkIndex}`}>\n                    {messages.map((message, messageIndex) => <li key={`message ${checkIndex} ${messageIndex}` }>{message}</li>)}\n                </ul>: null;\n\n                return <React.Fragment key={`doombuggy ${checkIndex}`}>\n                    <li key={`check result ${checkIndex}`}>{`${success}: ${result.what}`}</li>\n                    {messagesView}\n                </React.Fragment>;\n            })}\n        </ul>\n        {getUserMediaResult === null ? null :\n            getUserMediaResult instanceof MediaStream ?\n                <StreamView stream={getUserMediaResult}/> :\n                <ErrorView error={getUserMediaResult}/>}\n        <Hide hide={true}>\n            <Json content={navigator.mediaDevices.getSupportedConstraints()}/>\n        </Hide>\n    </div>;\n};\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Device, RecordingDirector } from './RecordingDirector';\n\nexport interface DeviceDemonstratorContext {\n    recordingDirector: RecordingDirector;\n}\n\nexport const Context = React.createContext<DeviceDemonstratorContext | void>(undefined);\n\nexport const useRecordingDirector = (): RecordingDirector => {\n    const maybe = useContext(Context);\n    if (undefined === maybe) {\n        throw new Error('Context not available in component tree parents');\n    }\n    return maybe.recordingDirector;\n};\n\nexport type StreamError = 'CouldNotOpen' | 'DeviceRemoved';\n\nexport interface VideoStream {\n    stream: MediaStream | null;\n    streamError: StreamError | 'none';\n}\n\nexport const useVideoStreamFrom = (device: Device | void): VideoStream => {\n    const recordingDirector = useRecordingDirector();\n    const [state, setState] = useState<VideoStream>({ stream: null, streamError: 'none' });\n    useEffect(() => {\n        if (undefined === device) {\n            return;\n        }\n        const mediaStreamSubscription = recordingDirector.videoStreamSubscriptionFor(device);\n        mediaStreamSubscription.onDeviceRemoved(() => {\n            mediaStreamSubscription.cancel()\n            setState({ stream: null, streamError: 'DeviceRemoved' });\n        });\n        mediaStreamSubscription.stream\n            .then(stream => setState(() => ({ stream, streamError: 'none' })))\n            .catch(() => setState(() => ({ stream: null, streamError: 'CouldNotOpen' })));\n        return () => {\n            mediaStreamSubscription.cancel();\n            setState(() => ({ stream: null, streamError: 'none' }));\n        };\n    }, [recordingDirector, device]);\n    return state;\n};\n","import React, { useEffect, useState } from 'react';\nimport { useRecordingDirector, useVideoStreamFrom } from './DeviceDemonstratorContext';\nimport { Device } from './RecordingDirector';\nimport { VideoElement } from '../VideoElement';\n\nexport const BigScreen: React.FC = () => {\n    const [device, setDevice] = useState<Device | void>(undefined);\n    const recordingDirector = useRecordingDirector();\n\n    useEffect(() => {\n        const handleDeviceSelectionChange = (device: Device | void): void => {\n            setDevice(() => device);\n        };\n        recordingDirector.addOnCameraSelectionChanged(handleDeviceSelectionChange);\n        return () => {\n            recordingDirector.removeOnCameraSelectionChanged(handleDeviceSelectionChange);\n        };\n    }, [recordingDirector]);\n    const { stream, streamError } = useVideoStreamFrom(device);\n    if (device === undefined) {\n        return <div>No device selected</div>;\n    }\n    if (!(streamError === 'none')) {\n        return <div>{streamError}</div>;\n    }\n    if (stream === null) {\n        return <div>Opening stream</div>;\n    }\n    const handleVideoClicked = () => {\n        recordingDirector.clearCameraSelection();\n    };\n    return (\n        <div>\n            <VideoElement srcObject={stream} autoPlay={true} onClick={handleVideoClicked}/>\n            <div>{stream.id}</div>\n        </div>\n    );\n};\n","import React, { CSSProperties, useEffect, useState } from 'react';\nimport { useRecordingDirector, useVideoStreamFrom } from './DeviceDemonstratorContext';\nimport { Device, RecordingDirector } from './RecordingDirector';\nimport { VideoElement } from '../VideoElement';\n\nexport interface CameraPreviewProps {\n    recordingDirector: RecordingDirector;\n    device: Device;\n    index: number;\n}\n\nexport const CameraPreview: React.FC<CameraPreviewProps> = (props) => {\n    const { recordingDirector, device, index } = props;\n    const { stream, streamError } = useVideoStreamFrom(device);\n\n    const handleSelect = () => {\n        recordingDirector.selectCamera(device);\n    };\n\n    const streamAvailable = streamError === 'none';\n    return (\n        <div>\n            <h4>Camera {index}</h4>\n            <ul>\n                <li>device label: {device.label}</li>\n                <li>device id: {device.deviceId}</li>\n                <li>group id: {device.groupId}</li>\n                <li>stream id: {stream?.id ?? 'no-stream'}</li>\n            </ul>\n            {!streamAvailable && <div>{streamError}</div>}\n            {streamAvailable && <VideoElement onClick={handleSelect} width={150} srcObject={stream} autoPlay={true}/>}\n        </div>\n    );\n};\n\nexport const CameraPicker: React.FC = () => {\n    const recordingDirector = useRecordingDirector();\n    const [{ showPreviews }, setState] = useState({ showPreviews: false, forceReRender: 0 });\n    useEffect(() => {\n        const availableDevicesChanged = () => {\n            setState((cur) => ({\n                ...cur,\n                forceReRender: cur.forceReRender + 1\n            }));\n        };\n        recordingDirector.addOnUpdateDevicesListener(availableDevicesChanged);\n        return () => {\n            recordingDirector.removeOnUpdateDevicesListener(availableDevicesChanged);\n        };\n    }, [recordingDirector]);\n\n    const handleShowPreview = () => setState(cur => ({ ...cur, showPreviews: true }));\n\n    const handleHidePreview = () => setState(cur => ({ ...cur, showPreviews: false }));\n\n    const button = showPreviews ? <button onClick={handleHidePreview}>Hide Previews</button> : <button onClick={handleShowPreview}>Show Previews</button>;\n    const previews = showPreviews ? recordingDirector.cameras()\n        .map((device, index) => <CameraPreview key={device.deviceId} index={index} device={device} recordingDirector={recordingDirector}/>) : null;\n    const style: CSSProperties = {\n        display: 'flex',\n        flexDirection: 'column'\n    };\n    return (\n        <div style={style}>\n            {button}\n            {previews}\n        </div>\n    );\n};\n","import { uuid } from 'uuidv4';\n\nexport type Device = Pick<MediaDeviceInfo, 'groupId' | 'deviceId' | 'kind' | 'label'>;\n\nexport type OnCameraSelectionChangedListener = (newCamera: Device | void) => void;\nexport type OnUpdateDevicesListener = () => void;\n\ninterface SubscriptionDetails {\n    readonly deviceIdentifier: DeviceIdentifier\n    readonly subscriptionIdentifier: SubscriptionIdentifier;\n    stream: Promise<MediaStream>\n}\n\nconst doNothing = () => {\n};\n\nexport interface MediaStreamSubscription {\n    readonly stream: Promise<MediaStream>;\n\n    onDeviceRemoved: (listener: () => void) => void\n\n    cancel(): void;\n}\n\nclass DefaultMediaStreamSubscription implements MediaStreamSubscription {\n    private _onDeviceRemoved = () => {\n    };\n    private _canceled = false;\n    private _deviceRemoved = false;\n\n    constructor(\n        private readonly recordingDirector: RecordingDirector,\n        public readonly subscriptionDetails: SubscriptionDetails) {\n    }\n\n    get stream() {\n        if (this._canceled || this._deviceRemoved) {\n            return Promise.reject('subscription canceled');\n        }\n        return this.subscriptionDetails.stream;\n    }\n\n    onDeviceRemoved(listener: () => void) {\n        this._onDeviceRemoved = listener;\n    }\n\n    deviceRemoved() {\n        this._deviceRemoved = true;\n        this._onDeviceRemoved();\n    }\n\n    cancel() {\n        this.recordingDirector.cancelSubscription(this.subscriptionDetails);\n        this._canceled = true;\n    }\n}\n\nconst getOrAdd = <Key, Value>(map: Map<Key, Value>, key: Key, creator: (key: Key) => Value): Value => {\n    const maybeValue = map.get(key);\n    if (maybeValue !== undefined) {\n        return maybeValue;\n    }\n    const value = creator(key);\n    map.set(key, value);\n    return value;\n};\n\ntype DeviceIdentifier = string;\ntype SubscriptionIdentifier = string;\n\ninterface SubscriptionLedgerEntry {\n    subscriptions: Map<SubscriptionIdentifier, DefaultMediaStreamSubscription>;\n    stream: Promise<MediaStream>;\n}\n\nclass SubscriptionLedger {\n    private readonly subscriptionsByDevice = new Map<DeviceIdentifier, SubscriptionLedgerEntry>();\n\n    addSubscriber(subscription: DefaultMediaStreamSubscription) {\n        const newEntry = () => ({ stream: subscription.stream, subscriptions: new Map<SubscriptionIdentifier, DefaultMediaStreamSubscription>() });\n        const details = subscription.subscriptionDetails;\n        const entry = getOrAdd(this.subscriptionsByDevice, details.deviceIdentifier, newEntry);\n        entry.subscriptions.set(details.subscriptionIdentifier, subscription);\n    }\n\n    subscriptionsTo(removedDeviceIds: string[]): DefaultMediaStreamSubscription[] {\n        return Array.from(this.subscriptionsByDevice.entries())\n            .filter(([d, _]) => removedDeviceIds.includes(d))\n            .map(([_, ledger]) => Array.from(ledger.subscriptions.values()))\n            .reduce((prev, cur) => prev.concat(cur), []);\n    }\n\n    removeSubscriber(subscriptionDetails: SubscriptionDetails, onNoMoreSubscribers: (stream: Promise<MediaStream>) => void = doNothing) {\n        const entry = this.subscriptionsByDevice.get(subscriptionDetails.deviceIdentifier);\n        if (entry === undefined) {\n            return;\n        }\n        entry.subscriptions.delete(subscriptionDetails.subscriptionIdentifier);\n        if (entry.subscriptions.size === 0) {\n            this.subscriptionsByDevice.delete(subscriptionDetails.deviceIdentifier);\n            onNoMoreSubscribers(entry.stream);\n        }\n    }\n\n    streamFor(device: Device): Promise<MediaStream> | undefined {\n        const entry = this.subscriptionsByDevice.get(device.deviceId);\n        if (entry === undefined) {\n            return undefined;\n        }\n        return entry.stream;\n    }\n}\n\nexport class RecordingDirector {\n    private readonly onUpdateDevicesListeners = new Set<OnUpdateDevicesListener>();\n    private readonly subscriptionLedger = new SubscriptionLedger();\n    private readonly devices: Array<Device> = [];\n    private onCameraSelectionChangedListeners: Set<OnCameraSelectionChangedListener> = new Set<OnCameraSelectionChangedListener>();\n    private selectedCamera: Device | undefined;\n\n    updateDevices(newDevices: Array<Device>) {\n        const availableDevicesId = newDevices.map(dev => dev.deviceId);\n        const removedDeviceIds = this.devices.filter(cur => !availableDevicesId.includes(cur.deviceId)).map(dev => dev.deviceId);\n\n        this.devices.splice(0, this.devices.length);\n        this.devices.push(...newDevices);\n        this.onUpdateDevicesListeners.forEach(it => it());\n        this.subscriptionLedger.subscriptionsTo(removedDeviceIds).forEach(sub => sub.deviceRemoved());\n    }\n\n    cameras() {\n        return this.devices.filter(device => device.kind === 'videoinput').filter(device => 'default' !== device.label);\n    }\n\n    videoStreamSubscriptionFor(device: Device): MediaStreamSubscription {\n        let subscriptionDetails = {\n            deviceIdentifier: device.deviceId,\n            stream: this.streamForDevice(device),\n            subscriptionIdentifier: uuid()\n        };\n        const subscription = new DefaultMediaStreamSubscription(this, subscriptionDetails);\n        this.subscriptionLedger.addSubscriber(subscription);\n        return subscription;\n    }\n\n    cancelSubscription(subscriptionDetails: SubscriptionDetails): void {\n        this.subscriptionLedger.removeSubscriber(subscriptionDetails, (stream) => stream.then(this.close).catch(doNothing));\n    }\n\n    private streamForDevice(device: Device): Promise<MediaStream> {\n        const maybeAlreadyAvailableStream = this.subscriptionLedger.streamFor(device);\n        if (maybeAlreadyAvailableStream !== undefined) {\n            return maybeAlreadyAvailableStream;\n        }\n        return this.videoStreamFor(device).then((stream) => {\n            // resolve the label of the device after the permission was given.\n            // we are in the then clause, so we can assume the permission was given.\n            if (device.label === '') {\n                navigator.mediaDevices.enumerateDevices().then((devices) => {\n                    const devicesWithLabels = devices.map(it => ({\n                        kind: it.kind,\n                        label: it.label,\n                        deviceId: it.deviceId,\n                        groupId: it.groupId\n                    }));\n                    console.log(devicesWithLabels);\n                    this.updateDevices(devicesWithLabels);\n                });\n\n            }\n            return stream;\n        });\n    }\n\n    private videoStreamFor(device: Device): Promise<MediaStream> {\n        return navigator.mediaDevices.getUserMedia({ video: { deviceId: device.deviceId } });\n    }\n\n    selectCamera(camera: Device) {\n        const alreadySelected = this.selectedCamera !== undefined\n            && this.selectedCamera.kind === camera.kind\n            && this.selectedCamera.groupId === camera.groupId\n            && this.selectedCamera.deviceId === camera.deviceId;\n        if (alreadySelected) {\n            console.log('already selected');\n            return;\n        }\n        this.selectedCamera = camera;\n        this.onCameraSelectionChangedListeners.forEach(listener => listener(this.selectedCamera));\n    }\n\n    clearCameraSelection() {\n        const cameraSelected = this.selectedCamera !== undefined;\n        if (cameraSelected) {\n            this.selectedCamera = undefined;\n            this.onCameraSelectionChangedListeners.forEach(listener => listener(this.selectedCamera));\n        }\n    }\n\n    addOnUpdateDevicesListener(listener: OnUpdateDevicesListener) {\n        this.onUpdateDevicesListeners.add(listener);\n    }\n\n    removeOnUpdateDevicesListener(listener: OnUpdateDevicesListener) {\n        this.onUpdateDevicesListeners.delete(listener);\n    }\n\n    addOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.add(listener);\n        listener(this.selectedCamera);\n    }\n\n    removeOnCameraSelectionChanged(listener: OnCameraSelectionChangedListener) {\n        this.onCameraSelectionChangedListeners.delete(listener);\n    }\n\n    private close(stream: MediaStream | null): void {\n        if (stream) {\n            stream.getTracks().forEach(track => track.stop());\n        }\n    }\n}\n","import React, { CSSProperties, useState } from 'react';\nimport { TestRig } from '../test-rig/test-rig';\nimport { BigScreen } from './BigScreen';\nimport { CameraPicker } from './CameraPicker';\nimport { Context } from './DeviceDemonstratorContext';\nimport { Device, RecordingDirector } from './RecordingDirector';\n\nexport const fetchDevices = (recordingDirector: RecordingDirector) => {\n    navigator.mediaDevices.enumerateDevices()\n        .then(function (mediaDeviceInfos) {\n            const toDevice = (mediaDeviceInfo: MediaDeviceInfo): Device => {\n                return {\n                    groupId: mediaDeviceInfo.groupId,\n                    deviceId: mediaDeviceInfo.deviceId,\n                    label: mediaDeviceInfo.label,\n                    kind: mediaDeviceInfo.kind\n                };\n            };\n            recordingDirector.updateDevices(mediaDeviceInfos.map(toDevice));\n        }).catch(function (err) {\n            console.log(err.name + ': ' + err.message);\n        }\n    );\n};\n\nconst logDeviceInformation = () => {\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n        console.log(`there are ${devices.length} devices`);\n        const devicesString = devices.map(device => `${device.kind} ${device.label} (${device.groupId}:${device.deviceId})`).join('\\n');\n        console.log(devicesString);\n    }).catch((e) => console.log(e));\n};\n\nexport const CameraDemonstrator: React.FC = () => {\n    const [showCameraPicker, setShowCameraPicker] = useState(true);\n    const style: CSSProperties = {\n        display: 'flex'\n    };\n    const sidebarStyle: CSSProperties = {\n        display: 'flex',\n        flexDirection: 'column'\n    };\n    return (\n        <>\n            <div style={style}>\n                <div style={sidebarStyle}>\n                    <button onClick={logDeviceInformation}>log device information</button>\n                    <button onClick={() => setShowCameraPicker((cur) => !cur)}>toggle camera picker</button>\n                    {showCameraPicker && <CameraPicker/>}\n                </div>\n                <BigScreen/>\n            </div>\n        </>\n    );\n};\n\nexport const setupCameraDemonstrator: () => React.FC = () => {\n    const recordingDirector = new RecordingDirector();\n    const updateDevices = () => fetchDevices(recordingDirector);\n    updateDevices();\n    navigator.mediaDevices.addEventListener('devicechange', updateDevices);\n    return () => {\n        return <Context.Provider value={{ recordingDirector }}>\n            <CameraDemonstrator/>\n            <TestRig/>\n        </Context.Provider>;\n    };\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { setupCameraDemonstrator } from './devices/camera/CameraDemonstrator';\n//import { formattedInputOne } from 'input/formatting/formatting-spike-one';\n//import { formattedInputTwo } from 'input/formatting/formatting-spike-two';\n\nconst Demonstrator = setupCameraDemonstrator();\n\nconst renderApplication = () => {\n    ReactDOM.render(<div>\n        <Demonstrator/>\n    </div>, document.getElementById('root'));\n};\nrenderApplication();\n"],"sourceRoot":""}